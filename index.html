<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width">
<title>Sticky Graph</title>
<style>

@-ms-viewport{
  width: device-width;
}

#drawing-board-div {
	position:fixed;
	left:  0px;
	right: 0px;
	top:   0px;
	bottom:0px;
	/* border: 3px solid #aaa; */
}

#drawing-board {
	display: inline-block;
	position: absolute;
	width: 100%;
	height: 100%;
	vertical-align: center;
}

.node {
	cursor: move;
	fill: #000;
	stroke: #000;
	stroke-width: 6px;
}

.link {
	fill:none;
	stroke: #999;
	stroke-width: 3px;
	stroke-dashoffset:-11px;
	stroke-linecap: round;
	pointer-events: none;
}

.link-background {
	fill:none;
	stroke: #999;
	stroke-width: 7px; /* 16px for width of vertex */
	opacity:0;
}

.node.red, .node.red.selected, .color-button-rect.red { fill: #f30; }
.link.red, .node.red { stroke: #f30; }
.node.orange, .node.orange.selected, .color-button-rect.orange { fill: #f90; }
.link.orange, .node.orange { stroke: #f90; }
.node.yellow, .node.yellow.selected, .color-button-rect.yellow { fill: #ee4; }
.link.yellow, .node.yellow { stroke: #ee4; }
.node.green, .node.green.selected, .color-button-rect.green { fill: #6e4; }
.link.green, .node.green { stroke: #6e4; }
.node.cyan, .node.cyan.selected, .color-button-rect.cyan { fill: #0dd; }
.link.cyan, .node.cyan { stroke: #0dd; }
.node.blue, .node.blue.selected, .color-button-rect.blue { fill: #27f; }
.link.blue, .node.blue { stroke: #27f; }
.node.violet, .node.violet.selected, .color-button-rect.violet { fill: #90c; }
.link.violet, .node.violet { stroke: #90c; }
.node.magenta, .node.magenta.selected, .color-button-rect.magenta { fill: #f5c; }
.link.magenta, .node.magenta { stroke: #f5c; }

.link.selected {
	stroke-width: 5px;
}

.node.selected, .link.selected {
	stroke: #fc0;
}

.node.pinned {
	fill: #999;
}

.label {
	text-anchor: middle;
	font-family: Arial, Helvetica, sans-serif;
	/* pointer-events: none; */
}

#graph-input-form {
	position:fixed;
	left: 15px;
	top:  15px;
	font-family: Arial, Helvetica, sans-serif;
}

#graph-input {
	background-color: rgba(255, 255, 255, 0.8);
}

#graph-input-type {
	left:15px;
	top: 50px;
}

.overlay {
	fill: none;
	pointer-events: all;
}

.edit-button {
	position:fixed;
	pointer-events: none;
}

.edit-button-rect {
	fill:white;
	stroke:#aaa;
	stroke-width:3px;
	fill-opacity:0.8;
	pointer-events: all;
}

.edit-button-rect.selected {
	stroke: #fc0;
	fill: #ffeb99;
}

.edit-button-path {
	stroke:black;
	stroke-width:3px;
	fill:black;
	pointer-events: none;
}

.edit-button-text {
	font-family: Arial, Helvetica, sans-serif;
	text-anchor:middle;
	dominant-baseline:central;
	font-size:16px;
	pointer-events: none;
}

.color-button-svg {
	position:fixed;
	pointer-events: none;
}

.color-button-rect {
	stroke:#aaa;
	stroke-width:3px;
	fill-opacity:1;
	pointer-events: all;
}

.color-button-rect.selected {
	stroke: #fc0;
}

#TikZ-button-text {
	font-family:"Times New Roman", Times, serif;
	text-anchor:middle;
	/* dominant-baseline:central; */
	font-size:17px;
	pointer-events: none;
}

#TikZ-div {
	position:fixed;
	top:55px;
	bottom:10px;
	left:52px;
	padding:0px;
	border:0px;
	margin-bottom:5px;
}

#TikZ-area, #matrix-area {
	height:100%;
	margin:0px;
	padding:2px;
	border:1px solid;
	background-color:rgba(255,255,255,.8);
	font-family:"Lucida Console", Monaco, monospace;
	overflow:auto;
	-moz-tab-size : 4;
	  -o-tab-size : 4;
	     tab-size : 4;
}

#TikZ-area {
	resize:horizontal;
}

#matrix-area {
	display:block;
	width:100px;
	height:75px;
	resize:both;
}

#keyboard-info {
	position: fixed;
	bottom: 10px;
	left: 52px;
	pointer-events: none;
	font-family:"Lucida Console", Monaco, monospace;
}

.label, #graph-input-form, #TikZ-button-text, .edit-button-text, #keyboard-info {
	-webkit-touch-callout: none; /* iOS Safari */
	-webkit-user-select: none;   /* Chrome/Safari/Opera */
	-khtml-user-select: none;    /* Konqueror */
	-moz-user-select: none;      /* Firefox */
	-ms-user-select: none;       /* IE/Edge */
	user-select: none;           /* non-prefixed version */
}


/* Large windows */
/* Looks good only through a height of 295px */
@media (min-width: 451px) {
	#add-v-button-svg       { right: 10px; bottom: 130px; }
	#add-e-button-svg       { right: 10px; bottom: 90px; }
	#delete-button-svg      { right: 10px; bottom: 50px; }
	#contract-button-svg    { right: 10px; bottom: 10px; }
	#select-v-button-svg    { right: 50px; bottom: 50px; }
	#select-e-button-svg    { right: 50px; bottom: 90px; }
	#select-none-button-svg { right: 50px; bottom: 10px; }
	#pin-button-svg         { right: 90px; bottom: 50px; }
	#unpin-button-svg       { right: 90px; bottom: 10px; }
	#TikZ-button-svg        { left: 10px; bottom: 50px; }
	#label-button-svg       { bottom: 10px; left: 10px; }
	#undo-button-svg        { bottom: 10px; right: 50%; }
	#redo-button-svg        { bottom: 10px; left: 50%; }
	#no-color-button-svg    { right: 50px; top: 50px; }
	#red-button-svg         { right: 90px; top: 10px; }
	#orange-button-svg      { right: 50px; top: 10px; }
	#yellow-button-svg      { right: 10px; top: 10px; }
	#green-button-svg       { right: 10px; top: 50px; }
	#cyan-button-svg        { right: 10px; top: 90px; }
	#blue-button-svg        { right: 50px; top: 90px; }
	#violet-button-svg      { right: 90px; top: 90px; }
	#magenta-button-svg     { right: 90px; top: 50px; }
}

/* very narrow window, so hope it is in portrait mode and put stuff on the bottom */
@media (max-width: 450px) and (min-width: 365px) {
	#add-v-button-svg       { bottom: 50px; left: 50%; margin-left: -177.5px; }
	#add-e-button-svg       { bottom: 50px; left: 50%; margin-left: -137.5px; }
	#delete-button-svg      { bottom: 50px; left: 50%; margin-left:  -97.5px; }
	#contract-button-svg    { bottom: 50px; left: 50%; margin-left:  -57.5px; }
	#select-v-button-svg    { display: none; }
	#select-e-button-svg    { display: none; }
	#select-none-button-svg { display: none; }
	#pin-button-svg         { display: none; }
	#unpin-button-svg       { display: none; }
	#TikZ-button-svg        { display: none; }
	#label-button-svg       { display: none; }
	#undo-button-svg        { bottom: 50px; left: 50%; margin-left:  102.5px; }
	#redo-button-svg        { bottom: 50px; left: 50%; margin-left:  142.5px; }
	#no-color-button-svg    { bottom: 10px; left: 50%; margin-left: -177.5px; }
	#red-button-svg         { bottom: 10px; left: 50%; margin-left: -137.5px; }
	#orange-button-svg      { bottom: 10px; left: 50%; margin-left:  -97.5px; }
	#yellow-button-svg      { bottom: 10px; left: 50%; margin-left:  -57.5px; }
	#green-button-svg       { bottom: 10px; left: 50%; margin-left:  -17.5px; }
	#cyan-button-svg        { bottom: 10px; left: 50%; margin-left:   22.5px; }
	#blue-button-svg        { bottom: 10px; left: 50%; margin-left:   62.5px; }
	#violet-button-svg      { bottom: 10px; left: 50%; margin-left:  102.5px; }
	#magenta-button-svg     { bottom: 10px; left: 50%; margin-left:  142.5px; }
}

@media (max-width: 364px) {
	#add-v-button-svg       { bottom: 35px; left: 50%; margin-left: -157.5px; }
	#add-e-button-svg       { bottom: 35px; left: 50%; margin-left: -122.5px; }
	#delete-button-svg      { bottom: 35px; left: 50%; margin-left:  -87.5px; }
	#contract-button-svg    { bottom: 35px; left: 50%; margin-left:  -52.5px; }
	#select-v-button-svg    { display: none; }
	#select-e-button-svg    { display: none; }
	#select-none-button-svg { display: none; }
	#pin-button-svg         { display: none; }
	#unpin-button-svg       { display: none; }
	#TikZ-button-svg        { display: none; }
	#label-button-svg       { display: none; }
	#undo-button-svg        { bottom: 35px; left: 50%; margin-left:  87.5px; }
	#redo-button-svg        { bottom: 35px; left: 50%; margin-left: 122.5px; }
	#no-color-button-svg    { bottom: 0px; left: 50%; margin-left: -157.5px; }
	#red-button-svg         { bottom: 0px; left: 50%; margin-left: -122.5px; }
	#orange-button-svg      { bottom: 0px; left: 50%; margin-left:  -87.5px; }
	#yellow-button-svg      { bottom: 0px; left: 50%; margin-left:  -52.5px; }
	#green-button-svg       { bottom: 0px; left: 50%; margin-left:  -17.5px; }
	#cyan-button-svg        { bottom: 0px; left: 50%; margin-left:   17.5px; }
	#blue-button-svg        { bottom: 0px; left: 50%; margin-left:   52.5px; }
	#violet-button-svg      { bottom: 0px; left: 50%; margin-left:   87.5px; }
	#magenta-button-svg     { bottom: 0px; left: 50%; margin-left:  122.5px; }
}



</style>
<body>
<!-- <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script> -->

<script src="d3.min.js"></script>


<div id="drawing-board-div"></div>



<form id="graph-input-form" action="" onsubmit="return load_graph();">
<select id="graph-mode-input" onchange="set_graph_mode()">
	<option value="graph6">Graph6</option>
	<!-- <option value="pathlist" disabled="disabled">Path List</option> -->
	<option value="togglematrix">Interactive A.M.</option>
	<option value="adjmatrix">Adj. Matrix</option>
	<option value="laplacian">Laplacian</option>
	<option value="normlaplacian">N. Laplacian</option>
	<option value="none">None</option>
</select>
<input type="text" id="graph-input" value="" size="30" autofocus>
<input type="submit" id="submit-button" value="Draw!"/>
<textarea id="matrix-area" readonly wrap="off" style="display:none;"></textarea>
<table id="togglematrix-table" style="text-align:center;font-size:12px;">
</table>
<!--  contenteditable: http://html5demos.com/contenteditable -->
</form>

<text id="keyboard-info"></text>














<script>

var width = window.innerWidth,
	height = window.innerHeight;

const DRAGPIN   = 0, // modes
      ADDEDGE   = 1,
      CONTRACT  = 2,
      DELETE    = 3,
      ADDVERTEX = 4,
      COLOR     = 5;
var mode = DRAGPIN;
var colorMode = ""; // this would be the color if we are in color mode. Otherwise unused.
var graphMode;
const NONE          = 0,
      GRAPH6        = 1,
      PATHLIST      = 2,
      TOGGLEMATRIX  = 3,
      ADJMATRIX     = 4,
      LAPLACIAN     = 5,
      NORMLAPLACIAN = 6;


var color = d3.scale.category10(); // FIX ME? do we ever use this?

var nodes = [],
	links = [];
var nextIDv = 0, nextIDe = 0; // when we edit the graph, maybe it would help to have a nice, unique id to go along with it? maybe we don't need ids at all, though?

var undoStack = [],
	redoStack = [];

var force = d3.layout.force()
	.nodes(nodes)
	.links(links)
	.charge(-600)
	.gravity(.1)
	.linkDistance(120)
	.size([width, height])
	.on("tick", tick)
	/* .linkStrength(.8); */
	.linkStrength(
		function(d,i)
		{
			while (i--)
				if (links[i].source == d.source && links[i].target == d.target || links[i].target == d.source && links[i].source == d.target)
					return 0;
			return .8;
		});
		

set_graph_mode();

var zoom = d3.behavior.zoom();

var drawingBoard = d3.select("#drawing-board-div")
	.append("svg")
	.attr("id", "drawing-board")
	.attr("preserveAspectRatio", "xMinYMin meet");

var addvButton = d3.select("body")
	.append("svg")
	.attr("id", "add-v-button-svg")
	.classed("edit-button",true);
addvButton.append("rect")
	.classed("edit-button-rect mode-button", true)
	.attr("id", "add-v-button")
	.on("click", add_vertex_button_press);
addvButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M 13 0 L -13 0 M 0 13 L 0 -13");
addvButton.append("text")
	.classed("edit-button-text", true)
	.attr("x","9")
	.attr("y","9")
	.text("v");

var addeButton = d3.select("body")
	.append("svg")
	.attr("id", "add-e-button-svg")
	.classed("edit-button",true);
addeButton.append("rect")
	.classed("edit-button-rect mode-button", true)
	.attr("id", "add-e-button")
	.on("click", add_edge_button_press);
addeButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M 13 0 L -13 0 M 0 13 L 0 -13");
addeButton.append("text")
	.classed("edit-button-text", true)
	.attr("x","9")
	.attr("y","9")
	.text("e");

var deleteButton = d3.select("body")
	.append("svg")
	.attr("id", "delete-button-svg")
	.classed("edit-button",true);
deleteButton.append("rect")
	.classed("edit-button-rect mode-button", true)
	.attr("id", "delete-button")
	.on("click", delete_button_press);
deleteButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M -9.1924 9.1924 L 9.1924 -9.1924 M -9.1924 -9.1924 L 9.1924 9.1924");

var contractButton = d3.select("body")
	.append("svg")
	.attr("id", "contract-button-svg")
	.classed("edit-button",true);
contractButton.append("rect")
	.classed("edit-button-rect mode-button", true)
	.attr("id", "contract-button")
	.on("click", contract_button_press);
contractButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M -13 13 L 13 -13");

var selectAllButton = d3.select("body")
	.append("svg")
	.attr("id", "select-v-button-svg")
	.classed("edit-button",true);
selectAllButton
	.append("defs")
	.append("svg:clipPath")
	.attr("id", "clip")
	.append("rect")
	.attr({id:"clip-rect", x:-17, y:-10, width:34, height:20});
selectAllButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", select_vertices_button_press);
selectAllButton.append("path")
	.classed("link",true)
	.attr("d", "M 11 0 L 17 0 M -11 0 L -17 0")
	.attr("clip-path", "url(#clip)");
selectAllButton.append("circle")
	.classed("node selected", true)
	.attr({cx:"0px", cy:"0px", r:"5px"});


var selectEdgesButton = d3.select("body")
	.append("svg")
	.attr("id", "select-e-button-svg")
	.classed("edit-button",true);
selectEdgesButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", select_edges_button_press);
selectEdgesButton.append("path")
	.classed("link selected",true)
	.attr("d", "M 11 0 L 17 0 M -11 0 L -17 0")
	.attr("clip-path", "url(#clip)");
selectEdgesButton.append("circle")
	.classed("node", true)
	.attr({cx:"0px", cy:"0px", r:"5px"});


var selectNoneButton = d3.select("body")
	.append("svg")
	.attr("id", "select-none-button-svg")
	.classed("edit-button",true);
selectNoneButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", select_none);
selectNoneButton.append("path")
	.classed("link",true)
	.attr("d", "M 11 0 L 17 0 M -11 0 L -17 0")
	.attr("clip-path", "url(#clip)");
selectNoneButton.append("circle")
	.classed("node", true)
	.attr({cx:"0px", cy:"0px", r:"5px"});


var pinButton = d3.select("body")
	.append("svg")
	.attr("id", "pin-button-svg")
	.classed("edit-button",true);
pinButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", pin_button_press);
pinButton.append("path")
	.classed("link",true)
	.attr("d", "M 11 0 L 17 0 M -11 0 L -17 0")
	.attr("clip-path", "url(#clip)");
pinButton.append("circle")
	.classed("node pinned", true)
	.attr({cx:"0px", cy:"0px", r:"5px"});


var unpinButton = d3.select("body")
	.append("svg")
	.attr("id", "unpin-button-svg")
	.classed("edit-button",true);
unpinButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", unpin_button_press);
unpinButton.append("path")
	.classed("link",true)
	.attr("d", "M 11 0 L 17 0 M -11 0 L -17 0")
	.attr("clip-path", "url(#clip)");
unpinButton.append("circle")
	.classed("node", true)
	.attr({cx:"0px", cy:"0px", r:"5px"});

var TikZButton = d3.select("body")
	.append("svg")
	.attr("id", "TikZ-button-svg")
	.classed("edit-button",true);
TikZButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", generate_TikZ);
TikZText = TikZButton.append("text")
	.attr("id","TikZ-button-text")
	.attr({x:"0px", y:"6px"});
TikZText.append("tspan").text("Ti");
TikZText.append("tspan").text("k").style("font-style","italic");
TikZText.append("tspan").text("Z");

var labelButton = d3.select("body")
	.append("svg")
	.attr("id", "label-button-svg")
	.classed("edit-button",true);
labelRect = labelButton.append("rect")
	.classed("edit-button-rect selected",true)
	.on("click", function () { 
		d3.select(this).classed("selected", !d3.select(this).classed("selected"));
		check_show_labels(); });
labelButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M -13 5.5 L 13 5.5 M -13 -5.5 L 13 -5.5 M 5.5 -13 L 5.5 13 M -5.5 -13 L -5.5 13");

var undoButton = d3.select("body")
	.append("svg")
	.attr("id", "undo-button-svg")
	.classed("edit-button",true);
undoRect = undoButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", undo);
undoButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M 13 0 L -13 0 M -13 0 l 7 7 M -13 0 l 7 -7");

var redoButton = d3.select("body")
	.append("svg")
	.attr("id", "redo-button-svg")
	.classed("edit-button",true);
redoRect = redoButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", redo);
redoButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M -13 0 L 13 0 M 13 0 l -7 7 M 13 0 l -7 -7");

var colors = ["magenta", "red", "orange", "yellow", "green", "cyan", "blue", "violet"];
var colorstring = colors.join(" ");

d3.select("body")
	.append("svg")
	.attr("id", "no-color-button-svg")
	.classed("color-button-svg",true)
	.append("rect")
	.classed("color-button-rect mode-button", true)
	.attr("id", "no-color-button")
	.on("click", function () {color_button_press("");})
	.style("fill", "black");

for (var color of colors)
{
	var f = function(c) {return function() {color_button_press(c);};};
	d3.select("body")
		.append("svg")
		.attr("id", color+"-button-svg")
		.classed("color-button-svg",true)
		.append("rect")
		.classed(color,true)
		.classed("color-button-rect mode-button", true)
		.attr("id", color+"-button")
		.on("click", f(color));
}

d3.selectAll(".color-button-svg")
	.attr("viewBox", "-20 -20 40 40 ")
	.attr("width", "35")
	.attr("height", "35");

d3.selectAll(".edit-button")
	.attr("viewBox", "-20 -20 40 40 ")
	.attr("width", "35")
	.attr("height", "35");

d3.selectAll(".edit-button-path")
	.attr("stroke-linecap","round");

d3.selectAll(".edit-button-rect")
	.attr({x:"-18.5px", y:"-18.5px", width:"37px", height:"37px", rx:"6px", ry:"6px"});

d3.selectAll(".color-button-rect")
	.attr({x:"-18.5px", y:"-18.5px", width:"37px", height:"37px", rx:"6px", ry:"6px"});

d3.select("body").append("div").attr("id", "TikZ-div").style("display", "none").append("textarea").attr("id", "TikZ-area").attr({id:"TikZ-area", readonly:true, wrap:"off"}).style("width", ""+(width/3)+"px");

var overlay = drawingBoard.append("rect")
	.attr("class", "overlay")
	.call(zoom.scaleExtent([.1, 8]).on("zoom", zoomHandler))
	.on("gesturechange", function () { d3.event.preventDefault(); })
	.on("gesturestart", function () { d3.event.preventDefault(); });

resize();
d3.select(window).on("resize", resize);

function resize() {
	windowWidth = window.innerWidth, windowHeight = window.innerHeight;
	dx = (windowWidth-width)/2, dy = (windowHeight-height)/2;
	drawingBoard.attr("viewBox", ""+(-dx)+" "+(-dy)+" "+(windowWidth)+" "+(windowHeight));
	overlay.attr({x:-dx, y: -dy, width:windowWidth, height: windowHeight});
	d3.select("#TikZ-area").style("max-width", ""+(windowWidth-110)+"px");
}

var zoomable = drawingBoard.append("g");

zoomable.append("g").attr("id", "links");
zoomable.append("g").attr("id", "nodes");
zoomable.append("g").attr("id", "labels");

var node = drawingBoard.select("#nodes").selectAll(".node"),
	link = drawingBoard.select("#links").selectAll(".link-parent"),
	label = drawingBoard.select("#labels").selectAll(".label");

function zoomHandler()
{
	zoomable.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

function getRandom(min, max) { return Math.random() * (max - min) + min; }

function xor(a,b) { return a?!b:b; }

function dist(x1,y1,x2,y2) { return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)); }

var drag = force.drag()
	.on("dragstart", drag_pin_drag_start)
	.on("drag", drag_pin_drag)
	.on("dragend", drag_pin_end);
var selecting;
var pinnedAtStart;
var selectedAtStart;
var x0, y0;
var nodeMoved;
var timeoutID;

function drag_pin_drag_start(d)
{
	clearKeyMode();
	var v = d3.select(this);
	selecting = d3.event.sourceEvent.shiftKey;
	pinnedAtStart = v.classed("pinned");
	selectedAtStart = v.classed("selected");
	x0 = d.x;
	y0 = d.y;
	nodeMoved = false;
	
	if (selecting)
		v.classed("selected", !selectedAtStart);
	
	d3.event.sourceEvent.preventDefault();
	
	timeoutID = setTimeout(function ()
		{
			v.classed("selected", !selectedAtStart);
			selecting = true;
		}, 750);
}

function drag_pin_drag(d)
{
	if (!nodeMoved && dist(d.x,d.y,x0,y0)>5)
	{
		float_nbr_edges(d);
		d3.select(this)
			.classed("selected", selectedAtStart)
			.classed("pinned", false);
		nodeMoved = true;
		clearTimeout(timeoutID);
	}
	d3.event.sourceEvent.preventDefault();
}

function drag_pin_end(d)
{
	clearTimeout(timeoutID);
	v = d3.select(this);
	if (!nodeMoved && !selecting)
	{
		switch (mode)
		{
		case COLOR:
			var hadColor = v.classed(colorMode);
			v.classed("selected "+colorstring, false)
				.each(function(d,i) {d.color=""});
			if (!hadColor)
				v.classed(colorMode, true)
					.each(function(d,i) {d.color=colorMode});
			break;
		case DELETE:
			save_state();
			delete_vertex(d);
			update_graph();
			write_graph();
			force.start();
			break;
		}
	}
	
	pinNode = xor(d3.event.sourceEvent.altKey, nodeMoved || xor(pinnedAtStart, (mode == DRAGPIN && !selecting)));
	if (pinNode)
		d3.select(this).each(pin);
	else
		d3.select(this).each(unpin);
	
	d3.event.sourceEvent.preventDefault();
}

var noDrag = d3.behavior.drag();

var addEdgeDrag = d3.behavior.drag()
	.on("dragstart", new_edge_drag_start)
	.on("drag", new_edge_drag)
	.on("dragend", new_edge_drag_end);

var dragLink, newEdgeX, newEdgeY;
var makingNewEdge = false;
function new_edge_drag_start(d)
{
	d.fixed |= 2;
	newEdgeX = d.x, newEdgeY = d.y;
	makingNewEdge = true;
	dragLink = drawingBoard.select("#links")
		.append("path")
		.classed("link", true)
		.attr("d", "M "+d.x+" "+d.y+" L "+d.x+" "+d.y)
		.style("stroke-dasharray", function (d) {return "" + (this.getTotalLength()) + " 11";});
	d3.event.sourceEvent.preventDefault();
}

function new_edge_drag(d)
{
	newEdgeX = d3.event.x, newEdgeY = d3.event.y;
	dragLink
		.attr("d", "M "+d.x+" "+d.y+" L "+newEdgeX+" "+newEdgeY)
		.style("stroke-dasharray", function (d) {return "" + (this.getTotalLength()) + " 11";});
	if (d3.event.sourceEvent.shiftKey)
		dragLink.classed("selected", true);
	else
		dragLink.classed("selected", false);
	d3.event.sourceEvent.preventDefault();
}

function new_edge_drag_end(d1)
{
	d1.fixed &= 1;
	makingNewEdge = false;
	v2 = drawingBoard.selectAll(".node").filter(function (d2) {
		return dist(d2.x,d2.y, newEdgeX, newEdgeY) <= 10; })
	dragLink.remove();
	if (!v2.empty())
	{
		d2 = v2.datum();
		if (d2.id != d1.id)
		{
			save_state();
			var newe = new_edge(d1, d2);
			
			update_graph();
			if (d3.event.sourceEvent.shiftKey)
				drawingBoard.selectAll(".link")
					.filter(function (d) { return d == newe; })
					.classed("selected", true);
			write_graph();
			force.start();
		}
	}
	d3.event.sourceEvent.preventDefault();
}

var curveEdgeDrag = d3.behavior.drag()
	.on("dragstart", curve_edge_drag_start)
	.on("drag", curve_edge_drag)
	.on("dragend", curve_edge_drag_end);
var dragLink; // replace this with an edge with a known id, so that we don't need a global variable to keep track of it? debatable.

function get_edge_path(d)
{
	var x1,x2,y1,y2;
	if (d.source.id < d.target.id)
		x1 = d.source.x, x2 = d.target.x, y1 = d.source.y, y2 = d.target.y;
	else
		x1 = d.target.x, x2 = d.source.x, y1 = d.target.y, y2 = d.source.y;
	var coords;
	if ("controlx" in d)
		coords = ["M", d.source.x, d.source.y, "Q", d.controlx, d.controly, d.target.x, d.target.y];
	else if (d.source == d.target)
	{
		scale = 5*d.copy+30
		coords = ["M", x1, y1, "C", x1+scale*(d.copy+1), y1-scale*2, ",", x1-scale*(d.copy+1), y1-scale*2, x2, y2];
	}
	else
	{
		var offset = d.copy - d.copies/2.,
			scale  = 10*offset/dist(x1,y1,x2,y2);
			//scale  = .1*offset;
		var controls = {x: (x1+x2)/2. + scale*(y1-y2), y: (y1+y2)/2.-scale*(x1-x2)};
		coords = ["M", x1, y1, "Q", controls.x, controls.y, x2, y2];
		//coords = ["M", d.source.x, d.source.y, "L", d.target.x, d.target.y];
	}
	return coords.join(" ");
}

function float_nbr_edges(d)
{
	var adj = link.selectAll("path")
		.filter(function (l) { return l.source.id == d.id || l.target.id == d.id; })
		.each(float_edge);
	adj.selectAll("path").attr("d", get_edge_path)
	adj.selectAll(".link").style("stroke-dasharray", function (d) {return "" + (this.getTotalLength()-22) + " 11";});
}

var sourcePinned, targetPinned, edgeMoved;

function curve_edge_drag_start(d)
{
	x0 = y0 = null;
	
	var edge = d3.select(this.parentNode).select(".link");
	selecting = d3.event.sourceEvent.shiftKey;
	selectedAtStart = edge.classed("selected");
	edgeMoved = false;
	if (selecting)
		edge.classed("selected", !selectedAtStart);
	timeoutID = setTimeout(function ()
		{
			edge.classed("selected", !selectedAtStart);
			selecting = true;
		}, 750);
	d3.event.sourceEvent.preventDefault();
}

function curve_edge_drag(d)
{
	if (x0 == null || y0 == null)
	{
		x0 = d3.event.x;
		y0 = d3.event.y;
	}
	
	var edgeParent = d3.select(this.parentNode);
	if (!edgeMoved && dist(d3.event.x,d3.event.y,x0,y0)>5)
	{
		clearTimeout(timeoutID);
		edgeParent.select(".link").classed("selected", selectedAtStart);
		if (d.source != d.target)
		{
			unfloat_edge(d);
			edgeMoved = true;
			sourcePinned = d.source.fixed;
			d.source.fixed = 1;
			targetPinned = d.target.fixed;
			d.target.fixed = 1;
		}
	}
	if (edgeMoved)
	{
		d.controlx = d3.event.x;
		d.controly = d3.event.y;
		
		edgeParent.selectAll("path")
			.attr("d", get_edge_path);
		edgeParent.select(".link")
			.style("stroke-dasharray", function (d) {return "" + (this.getTotalLength()-22) + " 11";});
	}
	d3.event.sourceEvent.preventDefault();
}

function curve_edge_drag_end(d)
{
	clearTimeout(timeoutID);
	var edgeParent = d3.select(this.parentNode),
		edge = edgeParent.select(".link");
	if (edgeMoved)
	{
		if (dist(d.controlx, d.controly, d.source.x, d.source.y) + dist(d.controlx, d.controly, d.target.x, d.target.y) >= 1.04*dist(d.source.x, d.source.y, d.target.x, d.target.y))
		{
			d3.select("#v"+d.source.id).each(pin);
			d3.select("#v"+d.target.id).each(pin);
		}
		else
		{
			float_edge(d);
		}
		tick();
	}
	else if (!selecting)
	{
		switch (mode)
		{
		case COLOR:
			var hadColor = edge.classed(colorMode);
			edge.classed("selected "+colorstring, false)
				.each(function(d,i) {d.color=""});
			if (!hadColor)
				edge.classed(colorMode, true)
					.each(function(d,i) {d.color=colorMode});
			break;
		case DELETE:
			save_state();
			delete_edge(d);
			update_graph();
			write_graph();
			force.start();
			break;
		case CONTRACT:
			save_state();
			contract_edge(d);
// 			update_graph();
			write_graph();
			force.start();
			break;
		}
	}
	
	d3.event.sourceEvent.preventDefault();
}


var swapLabelsDrag = d3.behavior.drag()
	.on("dragstart", swap_labels_drag_start)
	.on("drag", swap_labels_drag)
	.on("dragend", swap_labels_drag_end);

var swapLabelsX, swapLabelsY;

function swap_labels_drag_start(d)
{
	force.stop();
	swapLabelsX = d.x, swapLabelsY = d.y;
	clearKeyMode();
	d3.event.sourceEvent.preventDefault();
}

function swap_labels_drag(d)
{
	swapLabelsX = d3.event.x, swapLabelsY = d3.event.y;
	d3.select(this)
		.attr({x:swapLabelsX, y:swapLabelsY});
	d3.event.sourceEvent.preventDefault();
}

function swap_labels_drag_end(d1)
{
	v2 = drawingBoard.selectAll(".node").filter(function (d2) {
		return dist(d2.x,d2.y, swapLabelsX, swapLabelsY) <= 10; })
	if (!v2.empty() && v2.datum().id != d1.id)
	{
		d2 = v2.datum();
		save_state();
		swap_labels(d1.index, d2.index);
		tick();
	}
	else
	{
		d3.select(this).attr({x:d1.x, y:d1.y});
	}
	d3.event.sourceEvent.preventDefault();
}

var keyMode = null;
var vInput = [null,null], vIndex = 0;

function clearKeyMode()
{
	keyMode = null;
	vInput = [null,null], vIndex = 0;
	d3.select("#keyboard-info").text("");
}

function writeKeyboardInfo()
{
	var s = "";
	if (keyMode != null)
		s += keyMode + " ";
	if (vInput[0] != null)
		s += vInput[0]+" ";
	if (vInput[1] != null)
		s += vInput[1];
	d3.select("#keyboard-info").text(s);
}

d3.select("body")
	.on("keydown", keydown_handler);
function keydown_handler()
{
	var e = d3.event;
	var activeID = document.activeElement.id;
	if (activeID == "matrix-area" || activeID == "graph-mode-input" || activeID == "graph-input" || makingNewEdge)
	{
		clearKeyMode();
		return;
	}
	if (48 <= e.keyCode && e.keyCode <= 57) // a number was pressed!
	{
		if (vInput[vIndex] == null)
			vInput[vIndex] = e.keyCode-48;
		else
			vInput[vIndex] = 10*vInput[vIndex] + (e.keyCode-48);
		
		if (vInput[vIndex] < nodes.length)
			writeKeyboardInfo();
		else
			clearKeyMode();
	}
	else if (e.keyCode != 32 && e.keyCode != 13)
		clearKeyMode();
	
	if (!e.metaKey && !e.altKey && !e.ctrlKey)
	{
		switch (e.keyCode)
		{
		case 90:  // z: undo
			if (e.shiftKey)
				redo();
			else
				undo(); // shift-z redoes
			break;
		case 27:  // esc: switch to drag/pin mode
			change_mode(DRAGPIN, ""); break;
		case 187: // =: add vertex
			add_vertex_button_press(); break;
		case 189: // -: add edge
			add_edge_button_press(); break;
		case 8:   // delete: delete stuff
			delete_button_press(); break;
		case 191: // /: contract/identify stuff
			contract_button_press(); break;
		case 73:  // i: pin
			pin_button_press(); break;
		case 85:  // u: unpin
			unpin_button_press(); break;
		case 78:  // n: select all vertices
			select_vertices_button_press(); break;
		case 77:  // m: select all edges
			select_edges_button_press(); break;
		case 188: // ,: select nothing
			select_none(); break;
		case 88:  // x: color removal mode
			color_button_press(""); break;
		case 82:  // r: color mode red
			color_button_press("red"); break;
		case 79:  // o: color mode orange
			color_button_press("orange"); break;
		case 89:  // y: color mode yellow
			color_button_press("yellow"); break;
		case 71:  // g: color mode green
			color_button_press("green"); break;
		case 67:  // c: color mode cyan
			color_button_press("cyan"); break;
		case 66:  // b: color mode blue
			color_button_press("blue"); break;
		case 86:  // v: color mode violet
			color_button_press("violet"); break;
		case 80:  // p: color mode magenta
			color_button_press("magenta"); break;
		case 83:  // s: swap a labels for the specified pair of vertices
			keyMode = "Swap Labels";
			writeKeyboardInfo();
			break;
		case 16:  // shift: select a vertex or edge by keyboard
			keyMode = "Select";
			writeKeyboardInfo();
			break;
		case 32:  // space: separate a pair of vertices
			if (vInput[0] != null)
				vIndex=1;
			break;
		case 13:  // return: process vertex/vertex pair input
			if (keyMode == "Select")
			{
				var feature = null;
				if (vIndex == 0 && vInput[0] != null)
				{
					feature = drawingBoard
						.selectAll(".node")
						.filter(function (d) {return d.index == vInput[0];});
				}
				else if (vIndex == 1 && vInput[0] != null && vInput[1] != null)
				{
					feature = drawingBoard
						.selectAll(".link")
						.filter(function (d) { return (d.source.index == vInput[0] && d.target.index == vInput[1]) || (d.source.index == vInput[1] && d.target.index == vInput[0]); });
				}
				if (feature != null)
					feature.classed("selected", function (d) { return !d3.select(this).classed("selected");});
			}
			else if (keyMode == "Swap Labels")
			{
				if (vIndex == 1 && vInput[0] != null && vInput[1] != null)
					swap_labels(vInput[0],vInput[1]);
			}
			else if (mode == ADDEDGE)
			{
				var v0 = vInput[0], v1 = vInput[1];
				if (vIndex == 1 && v0 != null && v1 != null && v0 >= 0 && v0 < nodes.length && v1 >= 0 && v1 < nodes.length)
				{
					save_state();
					new_edge(nodes[vInput[0]], nodes[vInput[1]]);
					update_graph();
					write_graph();
					force.start();
				}
			}
			clearKeyMode();
			break;
		}
	}
}

function unpin(d)
{
	if (d.fixed & 1)
	{
		float_nbr_edges(d);
		force.resume();
	}
	d.fixed &= 6;
	d3.select(this).classed("pinned", false);
}

function pin(d)
{
	d3.select(this).classed("pinned", d.fixed |= 1);
}

function change_mode(m, c)
{
	d3.selectAll(".mode-button").classed("selected", false);
	mode = m;
	colorMode = c;
	switch (mode)
	{
		case DRAGPIN: break;
		case ADDEDGE:
			d3.select("#add-e-button").classed("selected", true);
			break;
		case ADDVERTEX:
			d3.select("#add-v-button").classed("selected", true);
			break;
		case CONTRACT:
			d3.select("#contract-button").classed("selected", true);
			break;
		case DELETE:
			d3.select("#delete-button").classed("selected", true);
			break;
		case COLOR:
			if (c == "")
				d3.select("#no-color-button").classed("selected", true);
			else
				d3.select("#" + c + "-button").classed("selected", true);
			break;
		default:
			console.error("unrecognized mode:" + m);
	}
	add_event_listeners();
}

function add_event_listeners()
{
	switch (mode)
	{
	case DRAGPIN:
	case CONTRACT:
	case DELETE:
	case COLOR:
		link.selectAll(".link-background").call(curveEdgeDrag);
		node.call(drag);
		break;
	case ADDEDGE:
		link.selectAll(".link-background").call(curveEdgeDrag);
		node.call(addEdgeDrag);
		break;
	case ADDVERTEX:
		console.error("unsupported feature: interactive add vertex");
		break;
	}
	label.call(swapLabelsDrag);
}

function pin_button_press()
{
	clearKeyMode();
	selected = drawingBoard.selectAll(".node.selected");
	if (selected.size() == 0)
		node.each(pin);
	else
		selected.each(pin);
}

function unpin_button_press()
{
	clearKeyMode();
	selected = drawingBoard.selectAll(".node.selected");
	if (selected.size() == 0)
		node.each(unpin);
	else
		selected.each(unpin);
}

function select_vertices_button_press()
{
	clearKeyMode();
	selected = drawingBoard.selectAll(".node.selected");
	if (selected.size() == nodes.length)
		selected.classed("selected", false);
	else
		node.classed("selected", true);
}

function select_edges_button_press()
{
	clearKeyMode();
	selected = drawingBoard.selectAll(".link.selected");
	if (selected.size() == links.length)
		selected.classed("selected", false);
	else
		drawingBoard.selectAll(".link").classed("selected", true);
}

function select_none() { clearKeyMode(); drawingBoard.selectAll(".selected").classed("selected", false); }

function swap_labels(l1, l2)
{
	if (l1<0 || l2 < 0 || l1 >=nodes.length || l2 >= nodes.length)
		return;
	var temp = nodes[l2];
	nodes[l2] = nodes[l1];
	nodes[l2].index = l2;
	nodes[l1] = temp;
	nodes[l1].index = l1;
	update_graph();
	write_graph();
}

function new_vertex()
{
	var newv = {id:nextIDv++, index:nodes.length, x:getRandom(0,width), y:getRandom(0,height), color:"", fixed:0};
	nodes.push(newv);
	return newv;
}

function new_edge(v1, v2)
{
	
	var newe = {source:v1, target:v2, color:"", copy:0, copies:0, controlx:null, id:nextIDe++};
	links.push(newe);
	float_edge(newe);
	return newe;
}

function float_edge(d)
{
	if ("controlx" in d)
	{
		var v1 = d.source, v2 = d.target;
		var othercopies = [];
		for (l of links) // if (l != d)
			if (((l.source == v1 && l.target == v2) || (l.source == v2 && l.target == v1)) && !("controlx" in l))
				othercopies.push(l);
	
		var numcopies = othercopies.length; // the number of other (floating) copies of this edge

		for (l of othercopies)
			l.copies = numcopies;
		d.copies = d.copy = numcopies;
		delete d.controlx; delete d.controly;
	}
}

function unfloat_edge(d)
{
	if (!("controlx" in d)) // if it was floating
	{
		for (l of links) if (l != d)
		{
			if ((l.source.id == d.source.id && l.target.id == d.target.id || l.source.id == d.target.id && l.target.id == d.source.id) && !("controlx" in l))
			{
				l.copies--;
				if (l.copy > d.copy)
					l.copy--;
			}
		}
	}
}

function delete_vertex(d)
{
	for (var i=0; i < links.length;)
	{
		if (links[i].source.id == d.id || links[i].target.id == d.id)
		{
			links[i] = links[links.length-1];
			links.length--;
		}
		else
			i++;
	}
	
	for (var i=d.index+1; i<nodes.length; i++)
	{
		nodes[i].index--;
		nodes[i-1]=nodes[i];
	}
	nodes.length--;
}

function delete_edge(d)
{
	var i = links.indexOf(d)
	if (i != -1)
	{
		unfloat_edge(d);
		links[i] = links[links.length-1];
		links.length--;
		return;
	}
}

// node.transition().duration(500).tween("", function(d) {var xinterp = d3.interpolateNumber(d.x, 500), yinterp = d3.interpolateNumber(d.y, 500); return function(t){d.x = d.px = xinterp(t); d.y = d.py = yinterp(t); tick();};}).ease("cubic-in").each("end", clear_graph)

function contract_edge(d)
{
	delete_edge(d);
	var newv;
	if (d.source == d.target)
		newv = d.source;
	else
		newv = identify_vertices([d.source.index, d.target.index]);
	update_graph();
	if (d3.event.shiftKey)
		drawingBoard.select("#v"+newv.id)
			.classed("selected", true);
}

function split_edge(d)
{
	var newv = new_vertex();
	if ("controlx" in d)
	{
		newv.x = d.controlx;
		newv.y = d.controly;
		delete d.controlx;
		delete d.controly;
	}
	else
	{
		newv.x = (d.source.x+d.target.x)/2;
		newv.y = (d.source.y+d.target.y)/2;
	}
	if (d.source.fixed && d.target.fixed)
		newv.fixed = 1;
	new_edge(newv, d.source).color = d.color; // leave it to update_graph to assign the color's class, pinned-ness
	d.source = newv;
}

function add_vertex_button_press()
{
	clearKeyMode();
	save_state();
	var edges_selected = false;
	
	//split edges if they are selected
	var selected = drawingBoard.selectAll(".link.selected");
	if (!selected.empty())
	{
		selected.each(split_edge);
		edges_selected = true;
		update_graph();
	}
	
	selected = drawingBoard.selectAll(".node.selected");
	if (!selected.empty() || !edges_selected)
	{
		var newv = new_vertex();
		selected.each(function (d,i) { new_edge(newv, d); });
		update_graph();
		if (d3.event.shiftKey)
			drawingBoard.select("#v"+newv.id)
				.classed("selected", true);
	}
	
	write_graph();
	force.start();
}


function add_edge_button_press()
{
	clearKeyMode();
	if (mode == ADDEDGE)
		change_mode(DRAGPIN, "");
	else
		change_mode(ADDEDGE, "");
}

function do_mouse_down(d)
{
	clearKeyMode();
	var feature=d3.select(this);
	if (("sourceEvent" in d3.event)?d3.event.sourceEvent.shiftKey:d3.event.shiftKey)
		feature.classed("selected", !feature.classed("selected"));
	else
	{
		switch (mode)
		{
		case COLOR:
			var hadColor = feature.classed(colorMode);
			feature
				.classed("selected "+colorstring, false)
				.each(function(d,i) {d.color=""});
			if (!hadColor)
				feature
					.classed(colorMode, true)
					.each(function(d,i) {d.color=colorMode});
			break;
		}
	}
}

function delete_button_press()
{
	clearKeyMode(); // FIX ME: maybe delete anything typed first?
	var changes=false;
	var selectedLinks = drawingBoard.selectAll(".link.selected");
	var selectedNodes = drawingBoard.selectAll(".node.selected");
	
	if (!selectedLinks.empty() || !selectedNodes.empty())
	{
		save_state();
		changes = true;
	}
	
	selectedLinks.each(delete_edge);
	selectedNodes.each(delete_vertex);
	
	if (changes)
	{
		update_graph();
		write_graph();
		force.start();
	}
	else
	{
		if (mode == DELETE)
			change_mode(DRAGPIN, "");
		else
			change_mode(DELETE, "");
	}
}

// identify vertices, preserving and potentially creating multi-edges
// verts is an array of indices
function identify_vertices(verts)
{
	if (verts.length.length == 0)
		return;
	var v2identified = [], nbr2edges = [];
	v2identified.length = nbr2edges.length = nodes.length;
	for (var i = 0; i < nodes.length; i++)
		v2identified[i] = false, nbr2edges[i] = [];
	for (var v of verts)
		v2identified[v] = true;
	var newvindex = verts.reduce(function (a,b) {return Math.min(a,b);});
	var newv = nodes[newvindex];
	// update edges
	for (var i = links.length-1; i>=0; i--)
	{
		var l = links[i], otherEnd = null;
		if (v2identified[l.source.index] && v2identified[l.target.index])
		{
			l.source = l.target = newv;
		}
		if (v2identified[l.source.index])
		{
			otherEnd = l.target.index;
			l.source = newv;
			l.copy = nbr2edges[otherEnd].length;
			nbr2edges[otherEnd].push(l);
		}
		else if (v2identified[l.target.index])
		{
			otherEnd = l.source.index;
			l.target = newv;
			l.copy = nbr2edges[otherEnd].length;
			nbr2edges[otherEnd].push(l);
		}
	}
	for (var edgelist of nbr2edges)
	{
		for (var l of edgelist)
		{
			delete l.controlx; delete l.controly; // float the edges
			l.copies = edgelist.length-1;
		}
	}
	
	var numContract = verts.length, sumx=0, sumy=0;
	for (var v of verts)
	{
		sumx += nodes[v].x;
		sumy += nodes[v].y;
	}
	nodes[newvindex].px = sumx/numContract;
	nodes[newvindex].py = sumy/numContract;
	nodes[newvindex].x = sumx/numContract;
	nodes[newvindex].y = sumy/numContract;
	
	verts.sort(function (a,b) {return a-b;}); // sort the list
	for (var i = verts.length-1; i > 0; i--) // go backwards, to avoid changing the indices as we delete the vertices, and skip the first one, which should be the resulting vertex
		delete_vertex(nodes[verts[i]]);
	return newv;
}

function contract_button_press()
{
	clearKeyMode();
	var toContract = [];
	var adj = [];
	toContract.length = nodes.length;
	adj.length = nodes.length;
	for (var i = 0; i < nodes.length; i++)
		toContract[i] = adj[i] = false;
	selectedNodes = drawingBoard.selectAll(".node.selected").each( function (d) {toContract[d.index] = true;} );
	selectedLinks = drawingBoard.selectAll(".link.selected");
	
	if (selectedNodes.empty() && selectedLinks.empty())
	{
		if (mode == CONTRACT)
			change_mode(DRAGPIN, "");
		else
			change_mode(CONTRACT, "");
		return;
	}
	
	if (selectedNodes.empty())
	{
		save_state();
		selectedLinks.each( contract_edge );
		
		write_graph();
		force.start();
		return;
	}
	
	if (selectedLinks.empty())
	{
		save_state();
		var vlist = [];
		selectedNodes.each(function (d) { vlist.push(d.index); } );
		var newv = identify_vertices(vlist);
		// FIX ME: either delete loops or display them.  neither is no good.
		update_graph();
		
		if (d3.event.shiftKey)
			drawingBoard.select("#v"+newv.id)
				.classed("selected", true);
		else
			select_none();
		write_graph();
		force.start();
		return;
	}
}

function color_button_press(c)
{
	clearKeyMode();
	if (d3.event.shiftKey)
	{
		if (c!="")
		{
			var colored = drawingBoard.selectAll("."+c);
			var alreadyAllSelected = true;
			colored.each(function(){if (!d3.select(this).classed("selected")) alreadyAllSelected = false;});
			colored.classed("selected", !alreadyAllSelected);
		}
	}
	else
	{
		var selected = drawingBoard.selectAll(".selected");
		if (selected.empty())
		{
			if (mode == COLOR && colorMode == c)
				change_mode(DRAGPIN, "");
			else
				change_mode(COLOR, c);
		}
		else
		{
			selected
				.classed("selected "+colorstring, false)
				.each(function(d,i) {d.color=c})
				.classed(c, true);
		}
	}
}

function generate_TikZ()
{
	button = d3.select(this);
	
	if (button.classed("selected") || nodes.length == 0)
	{
		button.classed("selected",false)
		d3.select("#TikZ-div")
			.style("display","none");
		return;
	}
	
	d3
	tikz = "% (In the preamble)\n\n\\usepackage{tikz}\n\\usetikzlibrary{backgrounds}\n\\tikzset{vertex/.style={draw=none, line width = 2.4pt, fill, inner sep = .09cm, circle}}\n\\tikzset{edge/.style={very thick, gray, line cap=round}}\n\n\n\n% (In the body)\n\n\\begin{tikzpicture}[scale=1]";
	
	var printLabels = labelRect.classed("selected");
	
// 	var min = Number.MAX_VALUE,
// 		max = Number.MIN_VALUE;
// 	
// 	for (var i = 0; i < nodes.length; i++)
// 	{
// 		min = Math.min(min, nodes[i].x);
// 		max = Math.max(max, nodes[i].x);
// 	}
// 	console.log(min);
// 	console.log(max);
// 	console.log(max-min);
// 	console.log(width);
	
	var min = 0, max = 60; // magic numbers... works about right for the force settings
	
	for (var i = 0; i < nodes.length; i++)
	{
		tikz += "\n\t\\node[vertex";
		if (nodes[i].color != "")
			tikz += ", " + nodes[i].color;
		if (printLabels)
			tikz += ", label=above:" + nodes[i].index;
		tikz += "] at (" + (nodes[i].x/(max-min)).toFixed(3) + "," + (-nodes[i].y/(max-min)).toFixed(3) + ") (v" + nodes[i].index + ") {};";
	}
	
	tikz += "\n\t\\begin{scope}[on background layer]";
	
	for (var i = 0; i < links.length; i++)
	{
		var l = links[i];
		tikz += "\n\t\t\\draw[edge";
		if (l.color != "")
			tikz += ", " + l.color;
		tikz += "] (v" + l.target.index + ") ";
		if ("controlx" in l)
		{
			tikz += ".. controls (" + ((l.target.x+2*l.controlx)/(3*(max-min))).toFixed(3) + ", " + ((-l.target.y-2*l.controly)/(3*(max-min))).toFixed(3) + ") and (" + ((l.source.x+2*l.controlx)/(3*(max-min))).toFixed(3) + ", " + ((-l.source.y-2*l.controly)/(3*(max-min))).toFixed(3) + ") .."
		}
		else
			tikz += "to";
		tikz += " (v" + l.source.index + ");";
	}
	
	tikz += "\n\t\\end{scope}\n\\end{tikzpicture}";
	
	button.classed("selected",true);
	d3.select("#TikZ-div")
		.style("display",null);
	d3.select("#TikZ-area")
		.text(tikz);
}

function check_show_labels()
{
	if (labelRect.classed("selected"))
		label.attr("visibility", "visible");
	else
		label.attr("visibility", "hidden");
}

function clear_graph()
{
	zoom.scale(1);
	zoom.translate([0,0]);
	zoomable.attr("transform", "");
	links.length=0;
	nodes.length=0;
	
	update_graph();
}

function update_graph()
{
	node = node.data(force.nodes(), function(d) { return d.id;});
	node
		.enter()
		.append("circle")
		.classed("node", true)
		.attr("id", function(d) {return "v"+d.id;})
		.attr("r", "5px")
		.each(function(d) {d3.select(this).classed(d.color, true);})
		.classed("pinned", function(d) {return d.fixed;});
	node.exit().remove();
	
	link = link.data(force.links(), function(d) { return d.id; });
	var newLinkParents = link.enter()
		.append("g").classed("link-parent", true);
	newLinkParents.append("path")
		.classed("link-background", true);
	newLinkParents.append("path")
		.classed("link", true)
		.each(function(d) {d3.select(this).classed(d.color, true);});
	link.exit().remove();
	
	label = label.data(force.nodes(), function(d) { return d.id;});
	label
		.text(function(d) { return d.index;})
		.enter()
		.append("text")
		.classed("label", true)
		.text(function(d) { return d.index;});
	label.exit().remove();
	add_event_listeners();
	check_show_labels();
}

function tick()
{
	node.attr("cx", function(d) { return d.x; })
		.attr("cy", function(d) { return d.y; });
	
	link.selectAll("path").attr("d", get_edge_path);
	link.selectAll(".link").style("stroke-dasharray", function (d) {return "" + (this.getTotalLength()-22) + " 11";});
	
	label.attr("x", function(d) { return d.x; })
		.attr("y", function(d) { return d.y; })
		.attr("dy", "-14");
}

function set_graph_mode()
{
	switch (document.getElementById("graph-mode-input").value)
	{
	case "none":          graphMode = NONE;          break;
	case "graph6":        graphMode = GRAPH6;        break;
	case "pathlist":      graphMode = PATHLIST;      break;
	case "togglematrix":  graphMode = TOGGLEMATRIX;  break;
	case "adjmatrix":     graphMode = ADJMATRIX;     break;
	case "laplacian":     graphMode = LAPLACIAN;     break;
	case "normlaplacian": graphMode = NORMLAPLACIAN; break;
	default:
		console.error("unrecognized graph mode: "+document.getElementById("graph-mode-input").value);
		return;
	}
	document.getElementById("graph-mode-input").blur();
	write_graph();
	switch (graphMode)
	{
	case GRAPH6:
	case PATHLIST:
		d3.select("#graph-input").style("display", null);
		document.getElementById("graph-input").focus();
		d3.select("#matrix-area").style("display", "none");
		d3.select("#togglematrix-table").style("display", "none");
		break;
	case ADJMATRIX:
	case LAPLACIAN:
	case NORMLAPLACIAN:
		d3.select("#graph-input").style("display", "none");
		d3.select("#matrix-area").style("display", null);
		d3.select("#togglematrix-table").style("display", "none");
		break;
	case TOGGLEMATRIX:
		d3.select("#graph-input").style("display", "none");
		d3.select("#matrix-area").style("display", "none");
		d3.select("#togglematrix-table").style("display", null);
		labelRect.classed("selected", true);
		check_show_labels();
		break;
	case NONE:
		d3.select("#graph-input").style("display", "none");
		d3.select("#matrix-area").style("display", "none");
		d3.select("#togglematrix-table").style("display", "none");
		break;
	}
	if (graphMode == ADJMATRIX)
	{
		d3.select("#matrix-area").attr("readonly", null);
		d3.select("#submit-button").style("display", null);
		document.getElementById("matrix-area").focus();
	}	
	else
	{
		d3.select("#matrix-area").attr("readonly", "");
		d3.select("#submit-button").style("display", "none");
	}
}

function write_graph()
{
	switch (graphMode)
	{
	case GRAPH6:        write_g6();            break;
	case PATHLIST:      write_pathlist();      break;
	case ADJMATRIX:     write_adjmatrix();     break;
	case LAPLACIAN:     write_laplacian();     break;
	case TOGGLEMATRIX:  write_togglematrix();  break;
	case NORMLAPLACIAN: write_normlaplacian(); break;
	}
}

function load_graph()
{
	switch (graphMode)
	{
	case GRAPH6:        load_g6();            break;
	case PATHLIST:      load_pathlist();      break;
	case ADJMATRIX:     load_adjmatrix();     break;
	}
	document.getElementById("graph-input").blur();
	return false;
}

// return an adjacency matrix for the current graph
function get_adjmatrix()
{
	var am = [];
	var n = nodes.length;
	for (var r=0; r<n; r++)
	{
		var row = [];
		for (var c=0; c<n; c++)
			row.push(0);
		am.push(row);
	}
	for (var l of links)
		am[l.source.index][l.target.index] = am[l.target.index][l.source.index] = 1;
	return am;
}

var pre="[[", interEntry=", ", interRow="],\n [", post="]]";

function write_adjmatrix()
{
	var am = get_adjmatrix();
	var n = nodes.length;
	var rows = [];
	for (var row of am)
		rows.push(row.join(interEntry));
	document.getElementById("matrix-area")
		.value = pre+rows.join(interRow)+post;
}

function load_adjmatrix()
{
	var ams = document.getElementById("matrix-area").value.trim();
	var flatam = ams
		.replace(/[^01]/g, "")
		.split("");
	var n = Math.sqrt(flatam.length);
	if (!Number.isInteger(n))
	{
		console.warn("Number of entries is not square");
		return;
	}
	var am = []
	for (var i=0; i<n; i++)
		am.push(flatam.slice(n*i, n*i+n));
	if (n==0)
	{
		clear_graph();
		console.warn("empty matrix found");
		return;
	}
	for (var i=0; i<n; i++)
	{
		if (am[i].length != n)
		{
			console.warn("Row "+i+" doesn't have length "+n);
			return;
		}
		if (am[i][i] != "0")
		{
			console.warn("Loop at vertex "+i+" not allowed");
			return;
		}
		for (var j=0; j<i; j++)
		{
			if (am[i][j] != am[j][i])
			{
				console.warn("Asymmetry at "+i+","+j+" not allowed");
				return;
			}
		}
	}
	pre = ams.match(/^[^01]*/)[0];
	post = ams.match(/[^01]*$/)[0];
	if (n >= 2)
	{
		interEntry = ams.match(/[01]([^01]*)[01]/)[1];
		rex = new RegExp("(?:[^01]*[01]){"+n+"}([^01]*)[01]");
		interRow = ams.match(rex)[1];
	}
	force.stop();
	for (var i=nodes.length; i<n; i++)
		nodes.push({id:i, index:i, x:getRandom(0,width), y:getRandom(0,height), color:"", fixed:0});
	nextIDv = nodes.length = n;
	links.length = 0;
	for (var i=0; i<n; i++)
		for (var j=0; j<i; j++)
			if (am[i][j] == "1")
				new_edge(nodes[i], nodes[j]);
	update_graph();
	document.getElementById("matrix-area")
		.value = pre+am.map(function (a) {return a.join(interEntry);}).join(interRow)+post;
	force.start();
}

function sum(v) { return v.reduce(function(x,y) {return x+y;}, 0); }

function write_laplacian()
{
	var lap = get_adjmatrix();
	var n = lap.length;
	for (var i=0; i<n; i++)
	{
		lap[i] = lap[i].map(function (x) {return -x;});
		lap[i][i] = -sum(lap[i]);
	}
	var rows = [];
	for (var row of lap)
		rows.push(row.join(interEntry));
	
	document.getElementById("matrix-area")
		.value = pre+rows.join(interRow)+post;
}

function load_laplacian()
{

}

function write_normlaplacian()
{
	var am = get_adjmatrix();
	var deg = am.map(sum);
	var nlap = [];
	var n = am.length;
	for (var i=0; i<n; i++)
	{
		nlap.push(am[i].map(function (x, j) {return (x==0)?0:-1/Math.sqrt(deg[i]*deg[j]);}));
		nlap[i][i] = (deg[i]==0)?0:1;
	}
	var rows = [];
	for (var row of nlap)
		rows.push(row.join(interEntry));
	
	document.getElementById("matrix-area")
		.value = pre+rows.join(interRow)+post;
}

function load_normlaplacian()
{

}

function write_togglematrix()
{
	var n = nodes.length;
	var labels = (n==0)?["(Add a vertex, first!)"]:[""];
	var matrixEntries = [];
	for (var i=0; i<n; i++)
	{
		labels.push(i);
		var row = [""];
		for (var j=0; j<n; j++)
		{
			row.push([i,j]);
		}
		matrixEntries.push(row);
	}
	var rowSelection = d3.select("#togglematrix-table").selectAll("tr")
		.data(labels);
	rowSelection.enter()
		.append("tr")
		.append("td")
		.text(function(d) {return d;});
	rowSelection.exit().remove();
	rowSelection.each(function(di,i) {
		if (i==0)
		{
			var entries = d3.select(this).selectAll("td").data(labels, function(d){return d;});
			entries.enter()
				.append("td")
				.text(function(d) {return d;});
			entries.exit().remove();
		}
		else
		{
			var entries = d3.select(this).selectAll("td").data(matrixEntries[di]);
			entries.enter()
				.append("td")
				.append("input")
				.attr("type", "checkbox")
				.attr("id", function(d) {return "cb"+d[0]+"-"+d[1];})
// 				.attr("disabled",function(d) {return d[0]==d[1]?"disabled":null;})
				.on("change", togglematrix_onchange);
			entries.exit().remove();
		}
	});
	
	for (var i=0; i<n; i++)
		for (var j=0; j<n; j++)
			document.getElementById("cb"+i+"-"+j).checked = false;
	for (var l of links)
	{
		document.getElementById("cb"+l.source.index+"-"+l.target.index).checked = document.getElementById("cb"+l.target.index+"-"+l.source.index).checked = true;
	}
}

function togglematrix_onchange(d)
{
	//force.stop(); // FIX ME: should I be stopping the force every time I change the graph?
	var checked = document.getElementById("cb"+d[1]+"-"+d[0]).checked = this.checked;
	var edge = links.filter(function(l) {return l.source.index==d[0] && l.target.index==d[1] || l.source.index==d[1] && l.target.index==d[0];});
	if (edge.length == 0 && checked)
	{
		save_state();
		new_edge(nodes[d[0]], nodes[d[1]]);
	}
	else if (edge.length!=0 && !checked)
	{
		save_state();
		edge.forEach(delete_edge);
	}
 	update_graph();
 	//write_graph();
	force.start();
}

function write_pathlist()
{

}

function load_pathlist()
{

}

function write_g6()
{
	var nv = nodes.length;
	var g6string = "";
	if (nv > 0)
	{
		g6string += String.fromCharCode(nv + 63);
		var len = Math.ceil(nv*(nv-1)/12);
		for (var i = 0; i < len; i++)
			g6string += String.fromCharCode(63);
		for (var l of links) if (l.source != l.target)
		{
			var V = Math.max(l.source.index, l.target.index);
			var v = Math.min(l.source.index, l.target.index);
			var c = Math.floor((V*(V-1)/2+v)/6);
			var b = 1 << (5-((V*(V-1)/2+v) % 6));
			g6string = g6string.substring(0, c+1) + String.fromCharCode(((g6string.charCodeAt(c+1) - 63) | b) + 63) + g6string.substring(c+2);
		}
	}
	document.getElementById("graph-input").value = g6string;
}

function load_g6()
{
	save_state();
	clear_graph();
	var g6string=document.getElementById("graph-input").value;
	var g6i=0;
	var i, j, k, x;
	
	// if (*g6 == ':')
// 	{
// 		alert("Cannot read sparse6 format\n");
// 		return false;
// 	}
	
	var nv = g6string.charCodeAt(g6i) - 63;

	for (nextIDv=0; nextIDv<nv; nextIDv++)
	{
		nodes[nextIDv]={id:nextIDv, index:nextIDv, x:getRandom(0,width), y:getRandom(0,height), color:"", fixed:0};
	}
	g6i++;
	
// 	if (g->nv > SMALLN) {
// 		for (i = 0, g->nv = 0; i < 3; ++i) {
// 			g->nv = (g->nv << 6) | (*g6++ -BIAS6);
// 		}
// 	}

// 	if (g->nv >= MAXNV)
// 	{
// 		fprintf(stderr, "Graph of size %d is larger than maximum size %d\n", g->nv, MAXNV);
// 		exit(1);
// 	}
	k = 1
	for (i = 1; i < nv; i++)
	{
		for (j = 0; j < i; j++)
		{
			k--;
			if (k==0)
			{
				k = 6;
				x = g6string.charCodeAt(g6i) - 63;
				g6i++;
			}
			if ((x >> 5) & 1)
			{
				new_edge(nodes[i], nodes[j]);
			}
			x <<= 1;
		}
	}
	
	update_graph();
	force.start();
}

function get_state()
{
	var nodesClone = JSON.parse(JSON.stringify(nodes));
	var linksClone = [];
	for (var l of links)
	{
		if ("controlx" in l)
			linksClone.push({source: nodesClone[l.source.index], target: nodesClone[l.target.index], color: l.color, controlx: l.controlx, controly: l.controly, copy: l.copy, copies: l.copies, id: l.id});
		else
			linksClone.push({source: nodesClone[l.source.index], target: nodesClone[l.target.index], color: l.color, copy: l.copy, copies: l.copies, id: l.id});
		
	}
	return {nodes:nodesClone, links:linksClone, nextIDv:nextIDv, nextIDe:nextIDe};
}
function save_state()
{
	undoStack.push(get_state());
	redoStack.length = 0;
}

function load_state(state)
{
	links.length=0;
	nodes.length=0;
	update_graph();
	for (var n of state.nodes)
		nodes.push(n);
	for (var l of state.links)
		links.push(l);
	nextIDv = state.nextIDv;
	nextIDe = state.nextIDe;
	update_graph();
	write_graph();
	force.start();
}

function undo()
{
	clearKeyMode();
	if (undoStack.length == 0)
		return;
	redoStack.push(get_state());
	load_state(undoStack.pop());
}

function redo()
{
	clearKeyMode();
	if (redoStack.length == 0)
		return;
	undoStack.push(get_state());
	load_state(redoStack.pop());
}

</script>

</body>
</html>
