<!DOCTYPE html>
<html>
<meta charset="utf-8">
<title>Sticky Graph</title>
<style>

#drawing-board-div {
	position:fixed;
	left:  0px;
	right: 0px;
	top:   0px;
	bottom:0px;
	/* border: 3px solid #aaa; */
}

#drawing-board {
	display: inline-block;
	position: absolute;
	width: 100%;
	height: 100%;
	vertical-align: center;
}

.node {
	cursor: move;
	fill: #000;
	stroke: #000;
	stroke-width: 6px;
}





.link {
	fill:none;
	stroke: #999;
	stroke-width: 3px;
	stroke-dashoffset:-11px;
	stroke-linecap: round;
}

.node.red, .node.red.selected, .color-button-rect.red { fill: #f00; }
.link.red, .node.red { stroke: #f00; }
.node.orange, .node.orange.selected, .color-button-rect.orange { fill: #f90; }
.link.orange, .node.orange { stroke: #f90; }
.node.yellow, .node.yellow.selected, .color-button-rect.yellow { fill: #ee4; }
.link.yellow, .node.yellow { stroke: #ee4; }
.node.green, .node.green.selected, .color-button-rect.green { fill: #0e0; }
.link.green, .node.green { stroke: #0e0; }
.node.blue, .node.blue.selected, .color-button-rect.blue { fill: #06f; }
.link.blue, .node.blue { stroke: #06f; }
.node.violet, .node.violet.selected, .color-button-rect.violet { fill: #c0c; }
.link.violet, .node.violet { stroke: #c0c; }

.link.selected {
	stroke: #fc0;
	stroke-width: 5px;
}

.node.selected {
	stroke: #fc0;
}

.node.pinned {
	fill: #999;
}

.label {
	text-anchor: middle;
	font-family: Arial, Helvetica, sans-serif;
	/* pointer-events: none; */
}

#graph-input-form {
	position:fixed;
	left: 15px;
	top:  15px;
	font-family: Arial, Helvetica, sans-serif;
}

#graph-input {
	background-color: rgba(255, 255, 255, 0.8);
}

#graph-input-type {
	left:15px;
	top: 50px;
}

.overlay {
	fill: none;
	pointer-events: all;
}

.edit-button {
	position:fixed;
	pointer-events: none;
}

.edit-button-rect {
	fill:white;
	stroke:#aaa;
	stroke-width:3px;
	fill-opacity:0.8;
	pointer-events: all;
}

.edit-button-rect.selected {
	stroke: #fc0;
	fill: #ffeb99;
}

.edit-button-path {
	stroke:black;
	stroke-width:3px;
	fill:black;
	pointer-events: none;
}

.edit-button-text {
	font-family: Arial, Helvetica, sans-serif;
	text-anchor:middle;
	dominant-baseline:central;
	font-size:16px;
	pointer-events: none;
}

.color-button {
	position:fixed;
	pointer-events: none;
}

.color-button-rect {
	stroke:#aaa;
	stroke-width:3px;
	fill-opacity:1;
	pointer-events: all;
}

.color-button-rect.selected {
	stroke: #fc0;
}

#TikZ-button-text {
	font-family:"Times New Roman", Times, serif;
	text-anchor:middle;
	/* dominant-baseline:central; */
	font-size:17px;
	pointer-events: none;
}

#TikZ-div {
	position:fixed;
	top:55px;
	bottom:10px;
	left:52px;
	padding:0px;
	border:0px;
	margin-bottom:5px;
}

#TikZ-area, #matrix-area {
	height:100%;
	margin:0px;
	padding:2px;
	border:1px solid;
	background-color:rgba(255,255,255,.8);
	font-family:"Lucida Console", Monaco, monospace;
	overflow:auto;
	-moz-tab-size : 4;
	  -o-tab-size : 4;
	     tab-size : 4;
}

#TikZ-area {
	resize:horizontal;
}

#matrix-area {
	display:block;
	width:100px;
	height:75px;
	resize:both;
}

.label, #graph-input-form, #TikZ-button-text, .edit-button-text {
	-webkit-touch-callout: none; /* iOS Safari */
	-webkit-user-select: none;   /* Chrome/Safari/Opera */
	-khtml-user-select: none;    /* Konqueror */
	-moz-user-select: none;      /* Firefox */
	-ms-user-select: none;       /* IE/Edge */
	user-select: none;           /* non-prefixed version */
}


</style>
<body>
<!-- <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script> -->

<script src="d3.min.js"></script>


<div id="drawing-board-div"></div>



<form id="graph-input-form" action="" onsubmit="return load_graph();">
<select id="graph-mode-input" onchange="set_graph_mode()">
	<option value="graph6">Graph6</option>
	<!-- <option value="pathlist" disabled="disabled">Path List</option> -->
	<option value="togglematrix">Interactive A.M.</option>
	<option value="adjmatrix">Adj. Matrix</option>
	<option value="laplacian">Laplacian</option>
	<option value="normlaplacian">N. Laplacian</option>
	<option value="none">None</option>
</select>
<input type="text" id="graph-input" value="" size="30" autofocus>
<input type="submit" id="submit-button" value="Draw!"/>
<textarea id="matrix-area" readonly wrap="off" style="display:none;"></textarea>
<table id="togglematrix-table" style="text-align:center;font-size:12px;">
</table>



<!-- 
<input type="submit" value="Draw!">
 -->
<!--  contenteditable: http://html5demos.com/contenteditable -->
</form>














<script>

var width = window.innerWidth,
	height = window.innerHeight;

const DRAGPIN   = 0, // modes
      ADDEDGE   = 1,
      CONTRACT  = 2,
      DELETE    = 3,
      ADDVERTEX = 4,
      COLOR     = 5;
var mode = DRAGPIN;
var colorMode = ""; // this would be the color if we are in color mode. Otherwise unused.
var graphMode;
const NONE          = 0,
      GRAPH6        = 1,
      PATHLIST      = 2,
      TOGGLEMATRIX  = 3,
      ADJMATRIX     = 4,
      LAPLACIAN     = 5,
      NORMLAPLACIAN = 6;


var color = d3.scale.category10(); // FIX ME? do we ever use this?

var nodes = [],
	links = [];
var nextID = 0; // when we edit the graph, maybe it would help to have a nice, unique id to go along with it? maybe we don't need ids at all, though?

var undoStack = [],
	redoStack = [];

var force = d3.layout.force()
	.nodes(nodes)
	.links(links)
	.charge(-600)
	.gravity(.1)
	.linkDistance(120)
	.linkStrength(.8)
	.size([width, height])
	.on("tick", tick);

set_graph_mode();

var zoom = d3.behavior.zoom();

var drawingBoard = d3.select("#drawing-board-div")
	.append("svg")
	.attr("id", "drawing-board")
	.attr("preserveAspectRatio", "xMinYMin meet");

var addvButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style({"right":"10px", "bottom":"130px"})
addvButton.append("rect")
	.classed("edit-button-rect mode-button", true)
	.attr("id", "add-v-button")
	.on("click", add_vertex_button_press);
addvButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M 13 0 L -13 0 M 0 13 L 0 -13");
addvButton.append("text")
	.classed("edit-button-text", true)
	.attr("x","9")
	.attr("y","9")
	.text("v");

var addeButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style({"right":"10px", "bottom":"90px"})
addeButton.append("rect")
	.classed("edit-button-rect mode-button", true)
	.attr("id", "add-e-button")
	.on("click", add_edge_button_press);
addeButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M 13 0 L -13 0 M 0 13 L 0 -13");
addeButton.append("text")
	.classed("edit-button-text", true)
	.attr("x","9")
	.attr("y","9")
	.text("e");

var deleteButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style({"right":"10px", "bottom":"50px"})
deleteButton.append("rect")
	.classed("edit-button-rect mode-button", true)
	.attr("id", "delete-button")
	.on("click", delete_button_press);
deleteButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M -9.1924 9.1924 L 9.1924 -9.1924 M -9.1924 -9.1924 L 9.1924 9.1924");

var contractButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style({"right":"10px", "bottom":"10px"})
contractButton.append("rect")
	.classed("edit-button-rect mode-button", true)
	.attr("id", "contract-button")
	.on("click", contract_button_press);
contractButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M -13 13 L 13 -13");

var selectAllButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style({right:"50px", "top":"50px"});
selectAllButton
	.append("defs")
	.append("svg:clipPath")
	.attr("id", "clip")
	.append("rect")
	.attr({id:"clip-rect", x:-17, y:-10, width:34, height:20});
selectAllButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", select_vertices_button_press);
selectAllButton.append("path")
	.classed("link",true)
	.attr("d", "M 11 0 L 17 0 M -11 0 L -17 0")
	.attr("clip-path", "url(#clip)");
selectAllButton.append("circle")
	.classed("node selected", true)
	.attr({cx:"0px", cy:"0px", r:"5px"});


var selectEdgesButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style({"right":"50px", "top":"90px"});
selectEdgesButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", select_edges_button_press);
selectEdgesButton.append("path")
	.classed("link selected",true)
	.attr("d", "M 11 0 L 17 0 M -11 0 L -17 0")
	.attr("clip-path", "url(#clip)");
selectEdgesButton.append("circle")
	.classed("node", true)
	.attr({cx:"0px", cy:"0px", r:"5px"});


var selectNoneButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style({"right":"50px", "top":"10px"});
selectNoneButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", select_none);
selectNoneButton.append("path")
	.classed("link",true)
	.attr("d", "M 11 0 L 17 0 M -11 0 L -17 0")
	.attr("clip-path", "url(#clip)");
selectNoneButton.append("circle")
	.classed("node", true)
	.attr({cx:"0px", cy:"0px", r:"5px"});


var pinButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style({"right":"90px", "top":"50px"});
pinButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", pin_button_press);
pinButton.append("path")
	.classed("link",true)
	.attr("d", "M 11 0 L 17 0 M -11 0 L -17 0")
	.attr("clip-path", "url(#clip)");
pinButton.append("circle")
	.classed("node pinned", true)
	.attr({cx:"0px", cy:"0px", r:"5px"});


var unpinButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style({"right":"90px", "top":"10px"});
unpinButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", unpin_button_press);
unpinButton.append("path")
	.classed("link",true)
	.attr("d", "M 11 0 L 17 0 M -11 0 L -17 0")
	.attr("clip-path", "url(#clip)");
unpinButton.append("circle")
	.classed("node", true)
	.attr({cx:"0px", cy:"0px", r:"5px"});

var TikZButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style("left", "10px")
	.style("bottom", "50px");
TikZButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", generate_TikZ);
TikZText = TikZButton.append("text")
	.attr("id","TikZ-button-text")
	.attr({x:"0px", y:"6px"});
TikZText.append("tspan").text("Ti");
TikZText.append("tspan").text("k").style("font-style","italic");
TikZText.append("tspan").text("Z");

var labelButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style("bottom", "10px")
	.style("left", "10px")
labelRect = labelButton.append("rect")
	.classed("edit-button-rect selected",true)
	.on("click", function () { 
		d3.select(this).classed("selected", !d3.select(this).classed("selected"));
		check_show_labels(); });
labelButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M -13 5.5 L 13 5.5 M -13 -5.5 L 13 -5.5 M 5.5 -13 L 5.5 13 M -5.5 -13 L -5.5 13");

var undoButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style("bottom", "10px")
	.style("right", "50%")
undoRect = undoButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", undo);
undoButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M 13 0 L -13 0 M -13 0 l 7 7 M -13 0 l 7 -7");

var redoButton = d3.select("body")
	.append("svg")
	.classed("edit-button",true)
	.style("bottom", "10px")
	.style("left", "50%")
redoRect = redoButton.append("rect")
	.classed("edit-button-rect", true)
	.on("click", redo);
redoButton.append("path")
	.classed("edit-button-path", true)
	.attr("d","M -13 0 L 13 0 M 13 0 l -7 7 M 13 0 l -7 -7");



d3.select("body")
	.append("svg")
	.classed("color-button",true)
	.style({"right":"10px", "top":"10px"})
	.append("rect")
	.classed("color-button-rect mode-button", true)
	.attr("id", "no-color-button")
	.on("click", function () {color_button_press("");})
	.style("fill", "black");

d3.select("body")
	.append("svg")
	.classed("color-button",true)
	.style({"right":"10px", "top":"50px"})
	.append("rect")
	.classed("red",true)
	.classed("color-button-rect mode-button", true)
	.attr("id", "red-button")
	.on("click", function () {color_button_press("red");});

d3.select("body")
	.append("svg")
	.classed("color-button",true)
	.style({"right":"10px", "top":"90px"})
	.append("rect")
	.classed("orange",true)
	.classed("color-button-rect mode-button", true)
	.attr("id", "orange-button")
	.on("click", function () {color_button_press("orange");});

d3.select("body")
	.append("svg")
	.classed("color-button",true)
	.style({"right":"10px", "top":"130px"})
	.append("rect")
	.classed("yellow",true)
	.classed("color-button-rect mode-button", true)
	.attr("id", "yellow-button")
	.on("click", function () {color_button_press("yellow");});

d3.select("body")
	.append("svg")
	.classed("color-button",true)
	.style({"right":"10px", "top":"170px"})
	.append("rect")
	.classed("green",true)
	.classed("color-button-rect mode-button", true)
	.attr("id", "green-button")
	.on("click", function () {color_button_press("green");});

d3.select("body")
	.append("svg")
	.classed("color-button",true)
	.style({"right":"10px", "top":"210px"})
	.append("rect")
	.classed("blue",true)
	.classed("color-button-rect mode-button", true)
	.attr("id", "blue-button")
	.on("click", function () {color_button_press("blue");});

d3.select("body")
	.append("svg")
	.classed("color-button",true)
	.style({"right":"10px", "top":"250px"})
	.append("rect")
	.classed("violet",true)
	.classed("color-button-rect mode-button", true)
	.attr("id", "violet-button")
	.on("click", function () {color_button_press("violet");});

d3.selectAll(".color-button")
	.attr("viewBox", "-20 -20 40 40 ")
	.attr("width", "35")
	.attr("height", "35");

d3.selectAll(".edit-button")
	.attr("viewBox", "-20 -20 40 40 ")
	.attr("width", "35")
	.attr("height", "35");

d3.selectAll(".edit-button-path")
	.attr("stroke-linecap","round");

d3.selectAll(".edit-button-rect")
	.attr({x:"-18.5px", y:"-18.5px", width:"37px", height:"37px", rx:"6px", ry:"6px"});

d3.selectAll(".color-button-rect")
	.attr({x:"-18.5px", y:"-18.5px", width:"37px", height:"37px", rx:"6px", ry:"6px"});

d3.select("body").append("div").attr("id", "TikZ-div").style("display", "none").append("textarea").attr("id", "TikZ-area").attr({id:"TikZ-area", readonly:true, wrap:"off"}).style("width", ""+(width/3)+"px");

var overlay = drawingBoard.append("rect")
	.attr("class", "overlay")
	.call(zoom.scaleExtent([.1, 8]).on("zoom", zoomHandler));

resize();
d3.select(window).on("resize", resize);

function resize() {
	windowWidth = window.innerWidth, windowHeight = window.innerHeight;
	dx = (windowWidth-width)/2, dy = (windowHeight-height)/2;
	drawingBoard.attr("viewBox", ""+(-dx)+" "+(-dy)+" "+(windowWidth)+" "+(windowHeight));
	overlay.attr({x:-dx, y: -dy, width:windowWidth, height: windowHeight});
	d3.select("#TikZ-area").style("max-width", ""+(windowWidth-110)+"px");
}

var zoomable = drawingBoard.append("g");

zoomable.append("g").attr("id", "links");
zoomable.append("g").attr("id", "nodes");
zoomable.append("g").attr("id", "labels");

var node = drawingBoard.select("#nodes").selectAll(".node"),
	link = drawingBoard.select("#links").selectAll(".link"),
	label = drawingBoard.select("#labels").selectAll(".label");

function zoomHandler()
{
	zoomable.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

function getRandom(min, max) { return Math.random() * (max - min) + min; }

function xor(a,b) { return a?!b:b; }

function dist(x1,y1,x2,y2) { return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)); }

var drag = force.drag()
	.on("dragstart", drag_pin_drag_start)
	.on("drag", drag_pin_drag)
	.on("dragend", drag_pin_end);
var shiftAtStart;
var pinnedAtStart;
var selectedAtStart;
var colorAtStart;
var x0, y0;
var nodeMoved;

function drag_pin_drag_start(d)
{
	var v = d3.select(this);
	shiftAtStart = d3.event.sourceEvent.shiftKey;
	pinnedAtStart = v.classed("pinned");
	selectedAtStart = v.classed("selected");
	colorAtStart = d.color;
	x0 = d.x;
	y0 = d.y;
	nodeMoved = false;
	
	v.each(do_mouse_down);
	
	pinNode = xor(d3.event.sourceEvent.altKey, nodeMoved || pinnedAtStart || (mode == DRAGPIN && !shiftAtStart));
	if (pinNode)
		v.each(pin);
	else
		v.each(unpin);
}

function drag_pin_drag(d)
{
	var v = d3.select(this);
	pinNode = xor(d3.event.sourceEvent.altKey, nodeMoved || pinnedAtStart || (mode == DRAGPIN && !shiftAtStart));
	if (pinNode)
		v.each(pin);
	else
		v.each(unpin);
	
	if (dist(d.x,d.y,x0,y0)>5 && !nodeMoved)
	{
		straighten_nbr_edges(d);
		v.classed("selected", selectedAtStart);
		v.classed("red orange yellow green blue violet", false)
		 .classed(colorAtStart, true);
		d.color = colorAtStart;
		nodeMoved = true;
	}
}

function drag_pin_end(d)
{
	pinNode = xor(d3.event.sourceEvent.altKey, nodeMoved || pinnedAtStart || (mode == DRAGPIN && !shiftAtStart));
	if (pinNode)
		d3.select(this).each(pin);
	else
		d3.select(this).each(unpin);
}

var noDrag = d3.behavior.drag();

var addEdgeDrag = d3.behavior.drag()
	.on("dragstart", new_edge_drag_start)
	.on("drag", new_edge_drag)
	.on("dragend", new_edge_drag_end);

var dragLink, newEdgeX, newEdgeY;

function new_edge_drag_start(d)
{
	newEdgeX = d.x, newEdgeY = d.y;
	dragLink = drawingBoard.select("#links")
		.append("path")
		.classed("link", true)
		.attr("d", "M "+d.x+" "+d.y+" L "+d.x+" "+d.y)
		.style("stroke-dasharray", function (d) {return "" + (this.getTotalLength()) + " 11";});
}

function new_edge_drag(d)
{
	newEdgeX = d3.event.x, newEdgeY = d3.event.y;
	dragLink
		.attr("d", "M "+d.x+" "+d.y+" L "+newEdgeX+" "+newEdgeY)
		.style("stroke-dasharray", function (d) {return "" + (this.getTotalLength()) + " 11";});
	if (d3.event.sourceEvent.shiftKey)
		dragLink.classed("selected", true);
	else
		dragLink.classed("selected", false);
}

function new_edge_drag_end(d1)
{
	v2 = drawingBoard.selectAll(".node").filter(function (d2) {
		return dist(d2.x,d2.y, newEdgeX, newEdgeY) <= 10; })
	dragLink.remove();
	if (!v2.empty())
	{
		d2 = v2.datum();
		if (d2.id != d1.id) // and if the edge isn't already there
		{
			for (var i = 0; i < links.length; i++)
				if (links[i].source.id == d1.id && links[i].target.id == d2.id ||
					links[i].source.id == d2.id && links[i].target.id == d1.id)
					return;
			save_state();
			links.push({source:d1, target:d2, color:""});
			update_graph();
			if (d3.event.sourceEvent.shiftKey)
				drawingBoard.selectAll(".link")
					.filter(function (d) { return d.source.id == d1.id && d.target.id == d2.id; })
					.classed("selected", true);
			write_graph();
			force.start();
		}
	}
}

var curveEdgeDrag = d3.behavior.drag()
	.on("dragstart", curve_edge_drag_start)
	.on("drag", curve_edge_drag)
	.on("dragend", curve_edge_drag_end);
var dragLink; // replace this with an edge with a known id, so that we don't need a global variable to keep track of it? debatable.

function get_edge_path(d)
{
	var coords;
	if ("controlx" in d)
		coords = ["M", d.source.x, d.source.y, "Q", d.controlx, d.controly, d.target.x, d.target.y];
	else
		coords = ["M", d.source.x, d.source.y, "L", d.target.x, d.target.y];
	return coords.join(" ");
}

function straighten_nbr_edges(d)
{
	drawingBoard.selectAll(".link")
		.filter(function (l) { return l.source.id == d.id || l.target.id == d.id; })
		.each(function (l) {delete l.controlx; delete l.controly;})
		.attr("d", get_edge_path)
		.style("stroke-dasharray", function (d) {return "" + (this.getTotalLength()-22) + " 11";});
}

var source_pinned, target_pinned;

function curve_edge_drag_start(d)
{
	source_pinned = d.source.fixed;
	d.source.fixed = 1;
	target_pinned = d.target.fixed;
	d.target.fixed = 1;
	d3.select(this).each(do_mouse_down);
}

function curve_edge_drag(d)
{
	d.controlx = d3.event.x;
	d.controly = d3.event.y;
	d3.select(this)
		.attr("d", get_edge_path)
		.style("stroke-dasharray", function (d) {return "" + (this.getTotalLength()-22) + " 11";});;
	
// 	if (d3.event.sourceEvent.shiftKey)
// 		dragLink.classed("selected", true);
// 	else
// 		dragLink.classed("selected", false);
}

function curve_edge_drag_end(d)
{
	if (dist(d.controlx, d.controly, d.source.x, d.source.y) + dist(d.controlx, d.controly, d.target.x, d.target.y) >= 1.04*dist(d.source.x, d.source.y, d.target.x, d.target.y))
	{
		d3.select("#v"+d.source.id).each(pin);
		d3.select("#v"+d.target.id).each(pin);
	}
	else
	{
		delete d.controlx;
		delete d.controly;
		d.source.fixed = source_pinned;
		d.target.fixed = target_pinned;
		d3.select(this).attr("d", get_edge_path);
	}
}


var swapLabelsDrag = d3.behavior.drag()
	.on("dragstart", swap_labels_drag_start)
	.on("drag", swap_labels_drag)
	.on("dragend", swap_labels_drag_end);

var swapLabelsX, swapLabelsY;

function swap_labels_drag_start(d)
{
	force.stop();
	swapLabelsX = d.x, swapLabelsY = d.y;
}

function swap_labels_drag(d)
{
	swapLabelsX = d3.event.x, swapLabelsY = d3.event.y;
	d3.select(this)
		.attr({x:swapLabelsX, y:swapLabelsY});
}

function swap_labels_drag_end(d1)
{
	v2 = drawingBoard.selectAll(".node").filter(function (d2) {
		return dist(d2.x,d2.y, swapLabelsX, swapLabelsY) <= 10; })
	if (!v2.empty() && v2.datum().id != d1.id)
	{
		d2 = v2.datum();
		save_state();
		swap_labels(d1.index, d2.index);
		tick();
	}
	else
	{
		d3.select(this).attr({x:d1.x, y:d1.y});
	}
}


var shiftv = [null,null], shiftIndex = 0;
d3.select("body")
	.on("keydown", keydown_handler)
	.on("keyup", keyup_handler);
function keydown_handler()
{
	var e = d3.event;
	var activeID = document.activeElement.id;
	if (activeID == "matrix-area" || activeID == "graph-mode-input" || activeID == "graph-input")
		return;
	switch (e.keyCode)
	{
		case 68:  // d: switch to drag/pin mode
			change_mode(DRAGPIN, ""); break;
		case 187: // =: add vertex
			add_vertex_button_press(); break;
		case 189: // -: add edge
			if (e.shiftKey && shiftv[0] != null)
				shiftIndex=1;
			else
				add_edge_button_press();
			break;
		case 8:   // delete: delete stuff
			delete_button_press(); break;
		case 191: // /: contract/identify stuff
			contract_button_press(); break;
		case 80:  // p: pin
			pin_button_press(); break;
		case 85:  // u: unpin
			unpin_button_press(); break;
		case 78:  // n: select all vertices
			select_vertices_button_press(); break;
		case 77:  // m: select all edges
			select_edges_button_press(); break;
		case 188: // ,: select nothing
			select_none(); break;
		case 88:  // x: color removal mode
			color_button_press(""); break;
		case 82:  // r: color mode red
			color_button_press("red"); break;
		case 79:  // o: color mode orange
			color_button_press("orange"); break;
		case 89:  // y: color mode yellow
			color_button_press("yellow"); break;
		case 71:  // g: color mode green
			color_button_press("green"); break;
		case 66:  // b: color mode blue
			color_button_press("blue"); break;
		case 86:  // v: color mode violet
			color_button_press("violet"); break;
		case 16:  // shift: select vertices and edges by keyboard
			shiftv = [null,null], shiftIndex = 0; break;
	}
	if (e.shiftKey && 48 <= e.keyCode && e.keyCode <= 57) // a number was pressed!
	{
		if (shiftv[shiftIndex] == null)
			shiftv[shiftIndex] = e.keyCode-48;
		else
			shiftv[shiftIndex] = 10*shiftv[shiftIndex] + (e.keyCode-48);
	}
}

function keyup_handler()
{
	var e = d3.event;
	var activeID = document.activeElement.id;
	if (e.keyCode != 16 || activeID == "matrix-area" || activeID == "graph-mode-input" || activeID == "graph-input")
		return;
	var feature = null;
	if (shiftIndex == 0 && shiftv[0] != null)
	{
		feature = drawingBoard
			.selectAll(".node")
			.filter(function (d) {return d.index == shiftv[0];});
	}
	else if (shiftIndex == 1 && shiftv[0] != null && shiftv[1] != null)
	{
		feature = drawingBoard
			.selectAll(".link")
			.filter(function (d) { return (d.source.index == shiftv[0] && d.target.index == shiftv[1]) || (d.source.index == shiftv[1] && d.target.index == shiftv[0]); });
	}
	if (feature != null)
		feature.classed("selected", function (d) { return !d3.select(this).classed("selected");});
	shiftv = [null,null], shiftIndex = 0;	
}

function unpin(d)
{
	if (d.fixed & 1)
	{
		straighten_nbr_edges(d);
		force.resume();
	}
	d.fixed &= 2;
	d3.select(this).classed("pinned", false);
}

function pin(d)
{
	d3.select(this).classed("pinned", d.fixed |= 1);
}

function change_mode(m, c)
{
	d3.selectAll(".mode-button").classed("selected", false);
	mode = m;
	colorMode = c;
	switch (mode)
	{
		case DRAGPIN: break;
		case ADDEDGE:
			d3.select("#add-e-button").classed("selected", true);
			break;
		case ADDVERTEX:
			d3.select("#add-v-button").classed("selected", true);
			break;
		case CONTRACT:
			d3.select("#contract-button").classed("selected", true);
			break;
		case DELETE:
			d3.select("#delete-button").classed("selected", true);
			break;
		case COLOR:
			if (c == "")
				d3.select("#no-color-button").classed("selected", true);
			else
				d3.select("#" + c + "-button").classed("selected", true);
			break;
		default:
			console.error("unrecognized mode:" + m);
	}
	add_event_listeners();
}

function add_event_listeners()
{
	switch (mode)
	{
		case DRAGPIN:
			link.on("click", null)
				.call(curveEdgeDrag);
			node.on("dblclick", unpin)
				.on("click", null)
				.call(drag);
		break;
		case ADDEDGE:
			link.on("click", null)
				.call(curveEdgeDrag);
			node.on("click", do_mouse_down)
				.on("dblclick", null)
				.call(addEdgeDrag);
			break;
		case ADDVERTEX:
			console.error("unsupported feature: interactive add vertex");
			break;
		case CONTRACT:
			link.on("click", function (d) {
					save_state(); contract_edge(d); update_graph(); write_graph(); force.start(); })
				.call(noDrag);
			node.on("dblclick", unpin)
				.on("click", null)
				.call(drag);
			break;
		case DELETE:
			link.on("click", function (d) {
					save_state(); delete_edge(d); update_graph(); write_graph(); force.start(); })
				.call(noDrag);
			node.on("dblclick", null)
				.on("click", function (d) {
					save_state(); delete_vertex(d); update_graph(); write_graph(); force.start(); })
				.call(noDrag);
			break;
		case COLOR:
			link.on("click", null)
				.call(curveEdgeDrag);
			node.on("dblclick", unpin)
				.on("click", null)
				.call(drag);
			break;
	}
	label.call(swapLabelsDrag);
}

function pin_button_press()
{
	selected = drawingBoard.selectAll(".node.selected");
	if (selected.size() == 0)
		node.each(pin);
	else
		selected.each(pin);
}

function unpin_button_press()
{
	selected = drawingBoard.selectAll(".node.selected");
	if (selected.size() == 0)
		node.each(unpin);
	else
		selected.each(unpin);
}

function select_vertices_button_press()
{
	selected = drawingBoard.selectAll(".node.selected");
	if (selected.size() == nodes.length)
		selected.classed("selected", false);
	else
		node.classed("selected", true);
}

function select_edges_button_press()
{
	selected = drawingBoard.selectAll(".link.selected");
	if (selected.size() == links.length)
		selected.classed("selected", false);
	else
		link.classed("selected", true);
}

function select_none() { drawingBoard.selectAll(".selected").classed("selected", false); }

function swap_labels(l1, l2)
{
	if (l1<0 || l2 < 0 || l1 >=nodes.length || l2 >= nodes.length)
		return;
	var temp = nodes[l2];
	nodes[l2] = nodes[l1];
	nodes[l2].index = l2;
	nodes[l1] = temp;
	nodes[l1].index = l1;
	update_graph();
	write_graph();
}

function new_vertex()
{
	var newv = {id:nextID, index:nodes.length, x:getRandom(0,width), y:getRandom(0,height), color:"", fixed:0};
	nodes.push(newv);
	nextID++;
	return newv;
}

function delete_vertex(d)
{
	for (var i=0; i < links.length;)
	{
		if (links[i].source.id == d.id || links[i].target.id == d.id)
		{
			links[i] = links[links.length-1];
			links.length--;
		}
		else
			i++;
	}
	
	for (var i=d.index+1; i<nodes.length; i++)
	{
		nodes[i].index--;
		nodes[i-1]=nodes[i];
	}
	nodes.length--;
}

function delete_edge(d)
{
	for (var i=0; i < links.length; i++)
	{
		if (links[i].source.id == d.source.id && links[i].target.id == d.target.id)
		{
			links[i] = links[links.length-1];
			links.length--;
			return;
		}
	}
}

function contract_edge(d, toDelete)
{
	if (d.source.id == d.target.id)
		return;
	var deleteNow = false;
	if (toDelete == null) // then delete the edges in this function
	{
		toDelete = [];
		toDelete.length = links.length;
		for (var i = 0; i < links.length; i++)
			toDelete[i] = false;
		deleteNow = true;
	}
	
	var adj=[];
	adj.length = nodes.length;
	for (var i = 0; i < nodes.length; i++)
		adj[i] = false;
	var v1 = Math.min(d.source.index, d.target.index);
	var v2 = Math.max(d.source.index, d.target.index);
	
	for (var i = 0; i < links.length;i++)
	{
		var l = links[i];
		
		if ((l.source.index == v1 && l.target.index == v2) || (l.target.index == v1 && l.source.index == v2))
		{
			toDelete[i] = true;
			l.source = l.target = nodes[v1];
		}
		else if (l.source.index == v1 || l.source.index == v2)
		{
			if (adj[l.target.index])
				toDelete[i] = true;
			adj[l.target.index] = true;
			l.source = nodes[v1];
		}
		else if (l.target.index == v1 || l.target.index == v2)
		{
			if (adj[l.source.index])
				toDelete[i] = true;
			adj[l.source.index] = true;
			l.target = nodes[v1];
		}
	}
	
	adj[d.source.index] = adj[d.target.index] = false;
	
	if (deleteNow)
	{
		for (var i = links.length - 1; i >= 0; i--)
		{
			if (toDelete[i])
			{
				links[i] = links[links.length-1];
				links.length--;
			}
		}
	}
	var avgx = (nodes[v1].x + nodes[v2].x)/2;
	var avgy = (nodes[v1].y + nodes[v2].y)/2;
	nodes[v1].px = avgx;
	nodes[v1].py = avgy;
	nodes[v1].x = avgx;
	nodes[v1].y = avgy;
	
	delete_vertex(nodes[v2]);
	
	if (d3.event.shiftKey)
			drawingBoard.select("#v"+v1)
				.classed("selected", true);
}

function split_edge(d)
{
	var newv = new_vertex();
	if ("controlx" in d)
	{
		newv.x = d.controlx;
		newv.y = d.controly;
		delete d.controlx;
		delete d.controly;
	}
	else
	{
		newv.x = (d.source.x+d.target.x)/2;
		newv.y = (d.source.y+d.target.y)/2;
	}
	if (d.source.fixed && d.target.fixed)
		newv.fixed = 1;
	links.push({source:newv, target:d.source, color:d.color}); // leave it to update_graph to assign the color's class, pinned-ness
	d.source = newv;
}

function add_vertex_button_press()
{
	save_state();
	var edges_selected = false;
	
	//split edges if they are selected
	var selected = drawingBoard.selectAll(".link.selected");
	if (!selected.empty())
	{
		selected.each(split_edge);
		edges_selected = true;
		update_graph();
	}
	
	selected = drawingBoard.selectAll(".node.selected");
	if (!selected.empty() || !edges_selected)
	{
		var newv = new_vertex();
		selected.each(function (d,i) { links.push({source:newv, target: d, color:""}); });
		update_graph();
		if (d3.event.shiftKey)
			drawingBoard.select("#v"+newv.id)
				.classed("selected", true);
	}
	
	write_graph();
	force.start();
}


function add_edge_button_press()
{
	if (mode == ADDEDGE)
		change_mode(DRAGPIN, "");
	else
		change_mode(ADDEDGE, "");
}

function do_mouse_down(d)
{
	var feature=d3.select(this);
	if (("sourceEvent" in d3.event)?d3.event.sourceEvent.shiftKey:d3.event.shiftKey)
		feature.classed("selected", !feature.classed("selected"));
	else
	{
		switch (mode)
		{
		case COLOR:
			var hadColor = feature.classed(colorMode);
			feature
				.classed("selected red orange yellow green blue violet", false)
				.each(function(d,i) {d.color=""});
			if (!hadColor)
				feature
					.classed(colorMode, true)
					.each(function(d,i) {d.color=colorMode});
			break;
		}
	}
}

function delete_button_press()
{
	var changes=false;
	var selectedLinks = drawingBoard.selectAll(".link.selected");
	var selectedNodes = drawingBoard.selectAll(".node.selected");
	
	if (!selectedLinks.empty() || !selectedNodes.empty())
		save_state();
	
	if (!selectedLinks.empty())
	{
		
		selectedLinks.each(delete_edge);
		changes = true;
	}
	
	if (!selectedNodes.empty())
	{
		selectedNodes.each(delete_vertex);
		changes = true;
	}
	
	if (changes)
	{
		update_graph();
		write_graph();
		force.start();
	}
	else
	{
		if (mode == DELETE)
			change_mode(DRAGPIN, "");
		else
			change_mode(DELETE, "");
	}
}

function contract_button_press()
{
	var toContract = [];
	var newv; // the index of the first vertex being contracted, which will be the resulting vertex.
	var adj = [];
	toContract.length = nodes.length;
	adj.length = nodes.length;
	for (var i = 0; i < nodes.length; i++)
		toContract[i] = adj[i] = false;
	selectedNodes = drawingBoard.selectAll(".node.selected").each( function (d) {toContract[d.index] = true;} );
	selectedLinks = drawingBoard.selectAll(".link.selected");
	
	if (selectedNodes.empty() && selectedLinks.empty())
	{
		if (mode == CONTRACT)
			change_mode(DRAGPIN, "");
		else
			change_mode(CONTRACT, "");
		return;
	}
	
	if (selectedNodes.empty())
	{
		save_state();
		toDelete = [];
		toDelete.length = links.length;
		for (var i = 0; i < links.length; i++)
			toDelete[i] = false;
		selectedLinks.each( function(d) { contract_edge(d, toDelete) } );
		for (var i = links.length - 1; i >= 0; i--) if (toDelete[i])
		{
			links[i] = links[links.length-1];
			links.length--;
		}
		update_graph();
		write_graph();
		force.start();
	}
	
	if (selectedLinks.empty())
	{
		save_state();
		for (var i = 0; i < links.length;)
		{
			var l = links[i];
			if (toContract[l.source.index] && !toContract[l.target.index])
			{
				adj[l.target.index] = true;
				links[i] = links[links.length-1];
				links.length--;
			}
			else if (!toContract[l.source.index] && toContract[l.target.index])
			{
				adj[l.source.index] = true;
				links[i] = links[links.length-1];
				links.length--;
			}
			else
				i++;
		}
	
		var numContract = 0, sumx=0, sumy=0;
		for (var i = 0; i < nodes.length; i++) if (toContract[i])
		{
			sumx += nodes[i].x;
			sumy += nodes[i].y;
			numContract++;
		}
	
		if (numContract == 0)
			return;
	
		for (var i = 0; i < nodes.length; i++)
		{
			if (toContract[i])
			{
				newv = i;
				toContract[i] = false;
				break;
			}
		}
		nodes[newv].px = sumx/numContract;
		nodes[newv].py = sumy/numContract;
		nodes[newv].x = sumx/numContract;
		nodes[newv].y = sumy/numContract;
	
		for (var i = nodes.length-1; i >=0; i--)
		{
			if (toContract[i]) // we won't delete a vertex before newv, and we don't
				delete_vertex(nodes[i]); // look at toContract or adj past where we
			else if (adj[i]) // are deleting vertices, so we shouldn't be corrupting
				links.push({source:nodes[i], target:nodes[newv], color:""}); // anything.
		}
	
		update_graph();
		if (d3.event.shiftKey)
			drawingBoard.select("#v"+newv)
				.classed("selected", true);
		else
			select_none();
		write_graph();
		force.start();
	}
}

function color_button_press(c)
{
	if (d3.event.shiftKey)
	{
		if (c!="")
		{
			var colored = drawingBoard.selectAll("."+c);
			var alreadyAllSelected = true;
			colored.each(function(){if (!d3.select(this).classed("selected")) alreadyAllSelected = false;});
			colored.classed("selected", !alreadyAllSelected);
		}
	}
	else
	{
		var selected = drawingBoard.selectAll(".selected");
		if (selected.empty())
		{
			if (mode == COLOR && colorMode == c)
				change_mode(DRAGPIN, "");
			else
				change_mode(COLOR, c);
		}
		else
		{
			selected
				.classed("selected red orange yellow green blue violet", false)
				.each(function(d,i) {d.color=c})
				.classed(c, true);
		}
	}
}

function generate_TikZ()
{
	button = d3.select(this);
	
	if (button.classed("selected") || nodes.length == 0)
	{
		button.classed("selected",false)
		d3.select("#TikZ-div")
			.style("display","none");
		return;
	}
	
	d3
	tikz = "% (In the preamble)\n\n\\usepackage{tikz}\n\\usetikzlibrary{backgrounds}\n\\tikzset{vertex/.style={draw=none, line width = 2.4pt, fill, inner sep = .09cm, circle}}\n\\tikzset{edge/.style={very thick, gray, line cap=round}}\n\n\n\n% (In the body)\n\n\\begin{tikzpicture}[scale=1]";
	
	var printLabels = labelRect.classed("selected");
	
// 	var min = Number.MAX_VALUE,
// 		max = Number.MIN_VALUE;
// 	
// 	for (var i = 0; i < nodes.length; i++)
// 	{
// 		min = Math.min(min, nodes[i].x);
// 		max = Math.max(max, nodes[i].x);
// 	}
// 	console.log(min);
// 	console.log(max);
// 	console.log(max-min);
// 	console.log(width);
	
	var min = 0, max = 60; // magic numbers... works about right for the force settings
	
	for (var i = 0; i < nodes.length; i++)
	{
		tikz += "\n\t\\node[vertex";
		if (nodes[i].color != "")
			tikz += ", " + nodes[i].color;
		if (printLabels)
			tikz += ", label=above:" + nodes[i].index;
		tikz += "] at (" + (nodes[i].x/(max-min)).toFixed(3) + "," + (-nodes[i].y/(max-min)).toFixed(3) + ") (v" + nodes[i].index + ") {};";
	}
	
	tikz += "\n\t\\begin{scope}[on background layer]";
	
	for (var i = 0; i < links.length; i++)
	{
		var l = links[i];
		tikz += "\n\t\t\\draw[edge";
		if (l.color != "")
			tikz += ", " + l.color;
		tikz += "] (v" + l.target.index + ") ";
		if ("controlx" in l)
		{
			tikz += ".. controls (" + ((l.target.x+2*l.controlx)/(3*(max-min))).toFixed(3) + ", " + ((-l.target.y-2*l.controly)/(3*(max-min))).toFixed(3) + ") and (" + ((l.source.x+2*l.controlx)/(3*(max-min))).toFixed(3) + ", " + ((-l.source.y-2*l.controly)/(3*(max-min))).toFixed(3) + ") .."
		}
		else
			tikz += "to";
		tikz += " (v" + l.source.index + ");";
	}
	
	tikz += "\n\t\\end{scope}\n\\end{tikzpicture}";
	
	button.classed("selected",true);
	d3.select("#TikZ-div")
		.style("display",null);
	d3.select("#TikZ-area")
		.text(tikz);
}

function check_show_labels()
{
	if (labelRect.classed("selected"))
		label.attr("visibility", "visible");
	else
		label.attr("visibility", "hidden");
}

function clear_graph()
{
	zoom.scale(1);
	zoom.translate([0,0]);
	zoomable.attr("transform", "");
	links.length=0;
	nodes.length=0;
	
	update_graph();
}

function update_graph()
{
	node = node.data(force.nodes(), function(d) { return d.id;});
	node
		.enter()
		.append("circle")
		.classed("node", true)
		.attr("id", function(d) {return "v"+d.id;})
		.attr("r", "5px")
		.each(function(d) {d3.select(this).classed(d.color, true);})
		.classed("pinned", function(d) {return d.fixed;});
	node.exit().remove();
	
	link = link.data(force.links(), function(d) { return d.source.id + "-" + d.target.id; });
	link.enter()
		.append("path")
		.attr("class", "link")
		.each(function(d) {d3.select(this).classed(d.color, true);})
	link.exit().remove();
	
	label = label.data(force.nodes(), function(d) { return d.id;});
	label
		.text(function(d) { return d.index;})
		.enter()
		.append("text")
		.classed("label", true)
		.text(function(d) { return d.index;});
	label.exit().remove();
	add_event_listeners();
	check_show_labels();
}

function tick()
{
	node.attr("cx", function(d) { return d.x; })
		.attr("cy", function(d) { return d.y; });
	
	link.attr("d", get_edge_path)
		.style("stroke-dasharray", function (d) {return "" + (this.getTotalLength()-22) + " 11";});
	
	label.attr("x", function(d) { return d.x; })
		.attr("y", function(d) { return d.y; })
		.attr("dy", "-14");
}

function set_graph_mode()
{
	switch (document.getElementById("graph-mode-input").value)
	{
	case "none":          graphMode = NONE;          break;
	case "graph6":        graphMode = GRAPH6;        break;
	case "pathlist":      graphMode = PATHLIST;      break;
	case "togglematrix":  graphMode = TOGGLEMATRIX;  break;
	case "adjmatrix":     graphMode = ADJMATRIX;     break;
	case "laplacian":     graphMode = LAPLACIAN;     break;
	case "normlaplacian": graphMode = NORMLAPLACIAN; break;
	default:
		console.error("unrecognized graph mode: "+document.getElementById("graph-mode-input").value);
		return;
	}
	document.getElementById("graph-mode-input").blur();
	write_graph();
	switch (graphMode)
	{
	case GRAPH6:
	case PATHLIST:
		d3.select("#graph-input").style("display", null);
		document.getElementById("graph-input").focus();
		d3.select("#matrix-area").style("display", "none");
		d3.select("#togglematrix-table").style("display", "none");
		break;
	case ADJMATRIX:
	case LAPLACIAN:
	case NORMLAPLACIAN:
		d3.select("#graph-input").style("display", "none");
		d3.select("#matrix-area").style("display", null);
		d3.select("#togglematrix-table").style("display", "none");
		break;
	case TOGGLEMATRIX:
		d3.select("#graph-input").style("display", "none");
		d3.select("#matrix-area").style("display", "none");
		d3.select("#togglematrix-table").style("display", null);
		labelRect.classed("selected", true);
		check_show_labels();
		break;
	case NONE:
		d3.select("#graph-input").style("display", "none");
		d3.select("#matrix-area").style("display", "none");
		d3.select("#togglematrix-table").style("display", "none");
		break;
	}
	if (graphMode == ADJMATRIX)
	{
		d3.select("#matrix-area").attr("readonly", null);
		d3.select("#submit-button").style("display", null);
		document.getElementById("matrix-area").focus();
	}	
	else
	{
		d3.select("#matrix-area").attr("readonly", "");
		d3.select("#submit-button").style("display", "none");
	}
}

function write_graph()
{
	switch (graphMode)
	{
	case GRAPH6:        write_g6();            break;
	case PATHLIST:      write_pathlist();      break;
	case ADJMATRIX:     write_adjmatrix();     break;
	case LAPLACIAN:     write_laplacian();     break;
	case TOGGLEMATRIX:  write_togglematrix();  break;
	case NORMLAPLACIAN: write_normlaplacian(); break;
	}
}

function load_graph()
{
	switch (graphMode)
	{
	case GRAPH6:        load_g6();            break;
	case PATHLIST:      load_pathlist();      break;
	case ADJMATRIX:     load_adjmatrix();     break;
	}
	document.getElementById("graph-input").blur();
	return false;
}

// return an adjacency matrix for the current graph
function get_adjmatrix()
{
	var am = [];
	var n = nodes.length;
	for (var r=0; r<n; r++)
	{
		var row = [];
		for (var c=0; c<n; c++)
			row.push(0);
		am.push(row);
	}
	for (var l of links)
		am[l.source.index][l.target.index] = am[l.target.index][l.source.index] = 1;
	return am;
}

var pre="[[", interEntry=", ", interRow="],\n [", post="]]";

function write_adjmatrix()
{
	var am = get_adjmatrix();
	var n = nodes.length;
	var rows = [];
	for (var row of am)
		rows.push(row.join(interEntry));
	document.getElementById("matrix-area")
		.value = pre+rows.join(interRow)+post;
}

function load_adjmatrix()
{
	var ams = document.getElementById("matrix-area").value.trim();
	var flatam = ams
		.replace(/[^01]/g, "")
		.split("");
	var n = Math.sqrt(flatam.length);
	if (!Number.isInteger(n))
	{
		console.warn("Number of entries is not square");
		return;
	}
	var am = []
	for (var i=0; i<n; i++)
		am.push(flatam.slice(n*i, n*i+n));
	if (n==0)
	{
		clear_graph();
		console.warn("empty matrix found");
		return;
	}
	for (var i=0; i<n; i++)
	{
		if (am[i].length != n)
		{
			console.warn("Row "+i+" doesn't have length "+n);
			return;
		}
		if (am[i][i] != "0")
		{
			console.warn("Loop at vertex "+i+" not allowed");
			return;
		}
		for (var j=0; j<i; j++)
		{
			if (am[i][j] != am[j][i])
			{
				console.warn("Asymmetry at "+i+","+j+" not allowed");
				return;
			}
		}
	}
	pre = ams.match(/^[^01]*/)[0];
	post = ams.match(/[^01]*$/)[0];
	if (n >= 2)
	{
		interEntry = ams.match(/[01]([^01]*)[01]/)[1];
		rex = new RegExp("(?:[^01]*[01]){"+n+"}([^01]*)[01]");
		interRow = ams.match(rex)[1];
	}
	force.stop();
	for (var i=nodes.length; i<n; i++)
		nodes.push({id:i, index:i, x:getRandom(0,width), y:getRandom(0,height), color:"", fixed:0});
	nextID = nodes.length = n;
	links.length = 0;
	for (var i=0; i<n; i++)
		for (var j=0; j<i; j++)
			if (am[i][j] == "1")
				links.push({source:nodes[i], target:nodes[j], color:""});
	update_graph();
	document.getElementById("matrix-area")
		.value = pre+am.map(function (a) {return a.join(interEntry);}).join(interRow)+post;
	force.start();
}

function sum(v) { return v.reduce(function(x,y) {return x+y;}, 0); }

function write_laplacian()
{
	var lap = get_adjmatrix();
	var n = lap.length;
	for (var i=0; i<n; i++)
	{
		lap[i] = lap[i].map(function (x) {return -x;});
		lap[i][i] = -sum(lap[i]);
	}
	var rows = [];
	for (var row of lap)
		rows.push(row.join(interEntry));
	
	document.getElementById("matrix-area")
		.value = pre+rows.join(interRow)+post;
}

function load_laplacian()
{

}

function write_normlaplacian()
{
	var am = get_adjmatrix();
	var deg = am.map(sum);
	var nlap = [];
	var n = am.length;
	for (var i=0; i<n; i++)
	{
		nlap.push(am[i].map(function (x, j) {return (x==0)?0:-1/Math.sqrt(deg[i]*deg[j]);}));
		nlap[i][i] = (deg[i]==0)?0:1;
	}
	var rows = [];
	for (var row of nlap)
		rows.push(row.join(interEntry));
	
	document.getElementById("matrix-area")
		.value = pre+rows.join(interRow)+post;
}

function load_normlaplacian()
{

}

function write_togglematrix()
{
	var n = nodes.length;
	var labels = (n==0)?["(Add a vertex, first!)"]:[""];
	var matrixEntries = [];
	for (var i=0; i<n; i++)
	{
		labels.push(i);
		var row = [""];
		for (var j=0; j<n; j++)
		{
			row.push([i,j]);
		}
		matrixEntries.push(row);
	}
	var rowSelection = d3.select("#togglematrix-table").selectAll("tr")
		.data(labels);
	rowSelection.enter()
		.append("tr")
		.append("td")
		.text(function(d) {return d;});
	rowSelection.exit().remove();
	rowSelection.each(function(di,i) {
		if (i==0)
		{
			var entries = d3.select(this).selectAll("td").data(labels, function(d){return d;});
			entries.enter()
				.append("td")
				.text(function(d) {return d;});
			entries.exit().remove();
		}
		else
		{
			var entries = d3.select(this).selectAll("td").data(matrixEntries[di]);
			entries.enter()
				.append("td")
				.append("input")
				.attr("type", "checkbox")
				.attr("id", function(d) {return "cb"+d[0]+"-"+d[1];})
				.attr("disabled",function(d) {return d[0]==d[1]?"disabled":null;})
				.on("change", togglematrix_onchange);
			entries.exit().remove();
		}
	});
	
	for (var i=0; i<n; i++)
		for (var j=0; j<n; j++)
			document.getElementById("cb"+i+"-"+j).checked = false;
	for (var l of links)
	{
		document.getElementById("cb"+l.source.index+"-"+l.target.index).checked = document.getElementById("cb"+l.target.index+"-"+l.source.index).checked = true;
	}
}

function togglematrix_onchange(d)
{
	//force.stop(); // FIX ME: should I be stopping the force every time I change the graph?
	var checked = document.getElementById("cb"+d[1]+"-"+d[0]).checked = this.checked;
	var edge = links.filter(function(l) {return l.source.index==d[0] && l.target.index==d[1] || l.source.index==d[1] && l.target.index==d[0];});
	if (edge.length == 0 && checked)
	{
		save_state()
		links.push({source:nodes[d[0]], target:nodes[d[1]], color:""});
	}
	else if (edge.length!=0 && !checked)
	{
		save_state()
		links[links.indexOf(edge[0])] = links[links.length-1];
		links.length--;
	}
 	update_graph();
 	//write_graph();
	force.start();
}

function write_pathlist()
{

}

function load_pathlist()
{

}

function write_g6()
{
	var nv = nodes.length;
	var g6string = "";
	if (nv > 0)
	{
		g6string += String.fromCharCode(nv + 63);
		var len = Math.ceil(nv*(nv-1)/12);
		for (var i = 0; i < len; i++)
			g6string += String.fromCharCode(63);
		for (var i = 0; i < links.length; i++)
		{
			var l = links[i];
			
			var V = Math.max(l.source.index, l.target.index);
			var v = Math.min(l.source.index, l.target.index);
			var c = Math.floor((V*(V-1)/2+v)/6);
			var b = 1 << (5-((V*(V-1)/2+v) % 6));
			g6string = g6string.substring(0, c+1) + String.fromCharCode(((g6string.charCodeAt(c+1) - 63) | b) + 63) + g6string.substring(c+2);
		}
	}
	document.getElementById("graph-input").value = g6string;
}

function load_g6()
{
	save_state();
	clear_graph();
	var g6string=document.getElementById("graph-input").value;
	var g6i=0;
	var i, j, k, x;
	
	// if (*g6 == ':')
// 	{
// 		alert("Cannot read sparse6 format\n");
// 		return false;
// 	}
	
	var nv = g6string.charCodeAt(g6i) - 63;

	for (nextID=0; nextID<nv; nextID++)
	{
		nodes[nextID]={id:nextID, index:nextID, x:getRandom(0,width), y:getRandom(0,height), color:"", fixed:0};
	}
	g6i++;
	
// 	if (g->nv > SMALLN) {
// 		for (i = 0, g->nv = 0; i < 3; ++i) {
// 			g->nv = (g->nv << 6) | (*g6++ -BIAS6);
// 		}
// 	}

// 	if (g->nv >= MAXNV)
// 	{
// 		fprintf(stderr, "Graph of size %d is larger than maximum size %d\n", g->nv, MAXNV);
// 		exit(1);
// 	}
	k = 1
	for (i = 1; i < nv; i++)
	{
		for (j = 0; j < i; j++)
		{
			k--;
			if (k==0)
			{
				k = 6;
				x = g6string.charCodeAt(g6i) - 63;
				g6i++;
			}
			if ((x >> 5) & 1)
			{
				links.push({source:nodes[i], target:nodes[j], color:""});
			}
			x <<= 1;
		}
	}
	
	update_graph();
	force.start();
}

function get_state()
{
	var nodesClone = JSON.parse(JSON.stringify(nodes));
	var linksClone = [];
	for (var l of links)
	{
		if ("controlx" in l)
			linksClone.push({source:nodesClone[l.source.index], target: nodesClone[l.target.index], color:l.color, controlx:l.controlx, controly:l.controly});
		else
			linksClone.push({source:nodesClone[l.source.index], target: nodesClone[l.target.index], color:l.color});
		
	}
	return {nodes:nodesClone, links:linksClone, nextID:nextID};
}
function save_state()
{
	undoStack.push(get_state());
	redoStack.length = 0;
}

function load_state(state)
{
	links.length=0;
	nodes.length=0;
	update_graph();
	for (var n of state.nodes)
		nodes.push(n);
	for (var l of state.links)
		links.push(l);
	nextID = state.nextID;
	update_graph();
	write_graph();
	force.start();
}

function undo()
{
	if (undoStack.length == 0)
		return;
	redoStack.push(get_state());
	load_state(undoStack.pop());
}

function redo()
{
	if (redoStack.length == 0)
		return;
	undoStack.push(get_state());
	load_state(redoStack.pop());
}

</script>

</body>
</html>
