<!DOCTYPE html>
<meta charset="utf-8">
<style>

#drawing-board-div {
	position:fixed;
	left:  0px;
	right: 0px;
	top:   0px;
	bottom:0px;
	/* border: 3px solid #aaa; */
}

#drawing-board {
    display: inline-block;
    position: absolute;
    width: 100%;
    height: 100%;
    vertical-align: center;
}

.node {
	cursor: move;
	fill: #000;
	stroke: #fff;
	stroke-width: 2px;
}

.node.pinned {
	stroke: #999;
}



.link {
  stroke: #999;
  stroke-width: 3px;
}

.node.red, .color-button-rect.red { fill: #f00; }
.link.red { stroke: #f00; }
.node.orange, .color-button-rect.orange { fill: #f90; }
.link.orange { stroke: #f90; }
.node.yellow, .color-button-rect.yellow { fill: #ee4; }
.link.yellow { stroke: #ee4; }
.node.green, .color-button-rect.green { fill: #0e0; }
.link.green { stroke: #0e0; }
.node.blue, .color-button-rect.blue { fill: #06f; }
.link.blue { stroke: #06f; }
.node.purple, .color-button-rect.purple { fill: #c0c; }
.link.purple { stroke: #c0c; }

.link.selected {
	stroke: #fc0;
	stroke-width: 5px;
}

.node.selected {
	stroke: #fc0;
	stroke-width:4px;
}
.label {
	text-anchor: middle;
	font-family: Arial, Helvetica, sans-serif;
}

#graph-input-form {
	position:fixed;
	left: 20px;
	top:  20px;
	font-family: Arial, Helvetica, sans-serif;
}

.overlay {
  fill: none;
  pointer-events: all;
}

.edit-button {
	position:fixed;
	pointer-events: none;
}

.edit-button-rect {
	fill:white;
	stroke:#aaa;
	stroke-width:3px;
	fill-opacity:0.8;
	pointer-events: all;
}

.edit-button-rect.selected {
	stroke: #fc0;
	fill: #ffeb99;
}

.edit-button-path {
	stroke:black;
	stroke-width:3px;
	fill:black;
	pointer-events: none;
}

.edit-button-text {
	font-family: Arial, Helvetica, sans-serif;
	text-anchor:middle;
	dominant-baseline:central;
	font-size:16px;
	pointer-events: none;
}

.color-button {
	position:fixed;
	pointer-events: none;
}

.color-button-rect {
	stroke:#aaa;
	stroke-width:3px;
	fill-opacity:1;
	pointer-events: all;
}

.color-button-rect.selected {
	stroke: #fc0;
}

#TikZ-button-text {
	font-family:"Times New Roman", Times, serif;
	text-anchor:middle;
	/* dominant-baseline:central; */
	font-size:17px;
	pointer-events: none;
}

#TikZ-div {
	position:fixed;
	top:55px;
	bottom:10px;
	left:52px;
	padding:0px;
	border:0px;
	margin-bottom:5px;
}

#TikZ-area {
	height:100%;
	margin:0px;
	padding:2px;
	border:1px solid;
	resize:horizontal;
	background-color:rgba(255,255,255,.8);
	font-family:"Lucida Console", Monaco, monospace;
}

.label, #graph-input-form, #TikZ-button-text, .edit-button-text {
  -webkit-touch-callout: none; /* iOS Safari */
  -webkit-user-select: none;   /* Chrome/Safari/Opera */
  -khtml-user-select: none;    /* Konqueror */
  -moz-user-select: none;      /* Firefox */
  -ms-user-select: none;       /* IE/Edge */
  user-select: none;           /* non-prefixed version */
}


</style>
<body>
<!-- 
<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
 -->
<script src="d3.min.js"></script>


<div id="drawing-board-div"></div>

<form id="graph-input-form" action="" onsubmit="return load_g6(this);">
Graph 6 <input type="text" id="graph-input" name="g6" value="" size="30" autofocus>
<!-- 
<input type="submit" value="Draw!">
 -->
</form>

<!-- 
<form id="show-labels-form" action="">
<label><input type="checkbox" id="show-labels-box" onclick="check_show_labels(this)" checked>Show Labels</label>
</form>
 -->
<div id="TikZ-div" style="display:none;">
	<textarea id="TikZ-area" readonly></textarea>
</div>












<script>

var width = 1300,
    height = 700;

const DRAGPIN   = 0, // modes
      ADDEDGE   = 1,
      CONTRACT  = 2,
      DELETE    = 3,
      ADDVERTEX = 4,
      COLOR     = 5;
var mode = DRAGPIN;
var colorMode = null; // this would be the color if we are in color mode. Otherwise unused.


var color = d3.scale.category10(); // FIX ME? do we ever use this?

var nodes = [],
    links = [];
var nextID = 0; // when we edit the graph, maybe it would help to have a nice, unique id to go along with it? maybe we don't need ids at all, though?

var force = d3.layout.force()
    .nodes(nodes)
    .links(links)
    .charge(-600)
    .gravity(.1)
    .linkDistance(120)
    .linkStrength(.8)
    .size([width, height])
    .on("tick", tick);

var zoom = d3.behavior.zoom();

var drawingBoard = d3.select("#drawing-board-div")
	.append("svg")
	.attr("id", "drawing-board")
	.attr("preserveAspectRatio", "xMinYMin meet")
	.attr("viewBox", "0 0 "+width+" "+height);

var addvButton = d3.select("body")
  .append("svg")
  .classed("edit-button",true)
  .style({"right":"10px", "bottom":"130px"})
addvButton.append("rect")
  .classed("edit-button-rect mode-button", true)
  .attr("id", "add-v-button")
  .on("click", add_vertex_button_press);
addvButton.append("path")
  .classed("edit-button-path", true)
  .attr("d","M 13 0 L -13 0 M 0 13 L 0 -13");
addvButton.append("text")
	.classed("edit-button-text", true)
	.attr("x","9")
	.attr("y","9")
	.text("v");

var addeButton = d3.select("body")
  .append("svg")
  .classed("edit-button",true)
  .style({"right":"10px", "bottom":"90px"})
addeButton.append("rect")
  .classed("edit-button-rect mode-button", true)
  .attr("id", "add-e-button")
  .on("click", add_edge_button_press);
addeButton.append("path")
  .classed("edit-button-path", true)
  .attr("d","M 13 0 L -13 0 M 0 13 L 0 -13");
addeButton.append("text")
	.classed("edit-button-text", true)
	.attr("x","9")
	.attr("y","9")
	.text("e");

var deleteButton = d3.select("body")
  .append("svg")
  .classed("edit-button",true)
  .style({"right":"10px", "bottom":"50px"})
deleteButton.append("rect")
  .classed("edit-button-rect mode-button", true)
  .attr("id", "delete-button")
  .on("click", delete_button_press);
deleteButton.append("path")
  .classed("edit-button-path", true)
  .attr("d","M -9.1924 9.1924 L 9.1924 -9.1924 M -9.1924 -9.1924 L 9.1924 9.1924");

var contractButton = d3.select("body")
  .append("svg")
  .classed("edit-button",true)
  .style({"right":"10px", "bottom":"10px"})
contractButton.append("rect")
  .classed("edit-button-rect mode-button", true)
  .attr("id", "contract-button")
  .on("click", contract_button_press);
contractButton.append("path")
  .classed("edit-button-path", true)
  .attr("d","M -13 13 L 13 -13");

var selectAllButton = d3.select("body")
  .append("svg")
  .classed("edit-button",true)
  .style({right:"50px", "top":"50px"});
selectAllButton.append("rect")
  .classed("edit-button-rect", true)
  .on("click", select_all_nodes);
selectAllButton.append("line")
  .classed("link",true)
  .attr({x1:"0px", y1:"0px", x2:"17px", y2:"0px"});
selectAllButton.append("line")
  .classed("link", true)
  .attr({x1:"0px", y1:"0px", x2:"-17px", y2:"0px"});
selectAllButton.append("circle")
  .classed("node selected", true)
  .attr({cx:"0px", cy:"0px", r:"9px"});


var selectEdgesButton = d3.select("body")
  .append("svg")
  .classed("edit-button",true)
  .style({"right":"50px", "top":"90px"});
selectEdgesButton.append("rect")
  .classed("edit-button-rect", true)
  .on("click", select_all_edges);
selectEdgesButton.append("line")
  .classed("link selected",true)
  .attr({x1:"0px", y1:"0px", x2:"17px", y2:"0px"});
selectEdgesButton.append("line")
  .classed("link selected", true)
  .attr({x1:"0px", y1:"0px", x2:"-17px", y2:"0px"});
selectEdgesButton.append("circle")
  .classed("node", true)
  .attr({cx:"0px", cy:"0px", r:"9px"});


var selectNoneButton = d3.select("body")
  .append("svg")
  .classed("edit-button",true)
  .style({"right":"50px", "top":"10px"});
selectNoneButton.append("rect")
  .classed("edit-button-rect", true)
  .on("click", select_none);
selectNoneButton.append("line")
  .classed("link",true)
  .attr({x1:"0px", y1:"0px", x2:"17px", y2:"0px"});
selectNoneButton.append("line")
  .classed("link", true)
  .attr({x1:"0px", y1:"0px", x2:"-17px", y2:"0px"});
selectNoneButton.append("circle")
  .classed("node", true)
  .attr({cx:"0px", cy:"0px", r:"9px"});


var pinButton = d3.select("body")
  .append("svg")
  .classed("edit-button",true)
  .style({"right":"90px", "top":"50px"});
pinButton.append("rect")
  .classed("edit-button-rect", true)
  .on("click", pin_all);
pinButton.append("line")
  .classed("link",true)
  .attr({x1:"0px", y1:"0px", x2:"17px", y2:"0px"});
pinButton.append("line")
  .classed("link", true)
  .attr({x1:"0px", y1:"0px", x2:"-17px", y2:"0px"});
pinButton.append("circle")
  .classed("node pinned", true)
  .attr({cx:"0px", cy:"0px", r:"9px"});


var unpinButton = d3.select("body")
  .append("svg")
  .classed("edit-button",true)
  .style({"right":"90px", "top":"10px"});
unpinButton.append("rect")
  .classed("edit-button-rect", true)
  .on("click", unpin_all);
unpinButton.append("line")
  .classed("link",true)
  .attr({x1:"0px", y1:"0px", x2:"17px", y2:"0px"});
unpinButton.append("line")
  .classed("link", true)
  .attr({x1:"0px", y1:"0px", x2:"-17px", y2:"0px"});
unpinButton.append("circle")
  .classed("node", true)
  .attr({cx:"0px", cy:"0px", r:"9px"});

var TikZButton = d3.select("body")
  .append("svg")
  .classed("edit-button",true)
  .style("left", "10px")
  .style("bottom", "50px");
TikZButton.append("rect")
  .classed("edit-button-rect", true)
  .on("click", generate_TikZ);
TikZText = TikZButton.append("text")
  .attr("id","TikZ-button-text")
  .attr({x:"0px", y:"6px"});
TikZText.append("tspan").text("Ti");
TikZText.append("tspan").text("k").style("font-style","italic");
TikZText.append("tspan").text("Z");

var labelButton = d3.select("body")
  .append("svg")
  .classed("edit-button",true)
  .style("bottom", "10px")
  .style("left", "10px")
labelRect = labelButton.append("rect")
  .classed("edit-button-rect selected", true)
  .on("click", function () { 
  		d3.select(this).classed("selected", !d3.select(this).classed("selected"));
  		check_show_labels(); });
labelButton.append("path")
  .classed("edit-button-path", true)
  .attr("d","M -13 5.5 L 13 5.5 M -13 -5.5 L 13 -5.5 M 5.5 -13 L 5.5 13 M -5.5 -13 L -5.5 13");



d3.select("body")
  .append("svg")
  .classed("color-button",true)
  .style({"right":"10px", "top":"10px"})
  .append("rect")
  .classed("color-button-rect mode-button", true)
  .attr("id", "no-color-button")
  .on("click", function () {color_button_press(d3.select(this), null);})
  .style("fill", "black");

d3.select("body")
  .append("svg")
  .classed("color-button",true)
  .style({"right":"10px", "top":"50px"})
  .append("rect")
  .classed("red",true)
  .classed("color-button-rect mode-button", true)
  .attr("id", "red-button")
  .on("click", function () {color_button_press(d3.select(this), "red");});

d3.select("body")
  .append("svg")
  .classed("color-button",true)
  .style({"right":"10px", "top":"90px"})
  .append("rect")
  .classed("orange",true)
  .classed("color-button-rect mode-button", true)
  .attr("id", "orange-button")
  .on("click", function () {color_button_press(d3.select(this), "orange");});

d3.select("body")
  .append("svg")
  .classed("color-button",true)
  .style({"right":"10px", "top":"130px"})
  .append("rect")
  .classed("yellow",true)
  .classed("color-button-rect mode-button", true)
  .attr("id", "yellow-button")
  .on("click", function () {color_button_press(d3.select(this), "yellow");});

d3.select("body")
  .append("svg")
  .classed("color-button",true)
  .style({"right":"10px", "top":"170px"})
  .append("rect")
  .classed("green",true)
  .classed("color-button-rect mode-button", true)
  .attr("id", "green-button")
  .on("click", function () {color_button_press(d3.select(this), "green");});

d3.select("body")
  .append("svg")
  .classed("color-button",true)
  .style({"right":"10px", "top":"210px"})
  .append("rect")
  .classed("blue",true)
  .classed("color-button-rect mode-button", true)
  .attr("id", "blue-button")
  .on("click", function () {color_button_press(d3.select(this), "blue");});

d3.select("body")
  .append("svg")
  .classed("color-button",true)
  .style({"right":"10px", "top":"250px"})
  .append("rect")
  .classed("purple",true)
  .classed("color-button-rect mode-button", true)
  .attr("id", "purple-button")
  .on("click", function () {color_button_press(d3.select(this), "purple");});

d3.selectAll(".color-button")
  .attr("viewBox", "-20 -20 40 40 ")
  .attr("width", "35")
  .attr("height", "35");

d3.selectAll(".edit-button")
  .attr("viewBox", "-20 -20 40 40 ")
  .attr("width", "35")
  .attr("height", "35");

d3.selectAll(".edit-button-path")
  .attr("stroke-linecap","round");

d3.selectAll(".edit-button-rect")
  .attr({x:"-18.5px", y:"-18.5px", width:"37px", height:"37px", rx:"6px", ry:"6px"});

d3.selectAll(".color-button-rect")
  .attr({x:"-18.5px", y:"-18.5px", width:"37px", height:"37px", rx:"6px", ry:"6px"});

drawingBoard.append("rect")
    .attr("class", "overlay")
    .attr("width", 100*width)
    .attr("height", 100*height)
    .call(zoom.scaleExtent([.1, 8]).on("zoom", zoomHandler));

var zoomable = drawingBoard.append("g");

zoomable.append("g").attr("id", "links");
zoomable.append("g").attr("id", "nodes");
zoomable.append("g").attr("id", "labels");

var node = drawingBoard.select("#nodes").selectAll(".node"),
    link = drawingBoard.select("#links").selectAll(".link"),
    label = drawingBoard.select("#labels").selectAll(".label");

function zoomHandler()
{
	zoomable.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

function getRandom(min, max)
{
	return Math.random() * (max - min) + min;
}

var drag = force.drag()
	.on("dragstart", pin);
var addEdgeDrag = d3.behavior.drag()
	.on("dragstart", new_edge_drag_start)
	.on("drag", new_edge_drag)
	.on("dragend", new_edge_drag_end);
var dragLink; // replace this with an edge with a known id, so that we don't need a global variable to keep track of it?  debatable.

function new_edge_drag_start(d)
{
	dragLink = drawingBoard.select("#links")
		.append("line")
		.classed("link", true)
		.attr({"x1":d.x, "y1":d.y, "x2":d.x, "y2":d.y});
}

function new_edge_drag(d)
{
	dragLink.attr({"x1":d.x, "y1":d.y, "x2":d3.event.x, "y2":d3.event.y});
	if (d3.event.sourceEvent.shiftKey)
		dragLink.classed("selected", true);
	else
		dragLink.classed("selected", false);
}

function new_edge_drag_end(d1)
{
	var x = dragLink.attr("x2"), y=dragLink.attr("y2");
	v2 = drawingBoard.selectAll(".node").filter(function (d2) {
		return ((d2.x - x) * (d2.x - x) + (d2.y - y) * (d2.y - y)) <= 100; })
	dragLink.remove();
	if (!v2.empty())
	{
		d2 = v2.datum();
		if (d2.id != d1.id) // and if the edge isn't already there
		{
			for (var i = 0; i < links.length; i++)
				if (links[i].source.id == d1.id && links[i].target.id == d2.id ||
					links[i].source.id == d2.id && links[i].target.id == d1.id)
					return;
			links.push({source:d1, target:d2});
			update_graph();
			if (d3.event.sourceEvent.shiftKey)
				drawingBoard.selectAll(".link")
					.filter(function (d) { return d.source.id == d1.id && d.target.id == d2.id; })
					.classed("selected", true);
			write_g6();
			force.start();
		}
	}
}

function unpin(d)
{
	d3.select(this).classed("pinned", d.fixed = false);
	force.resume();
}

function pin(d)
{
	if ((d3.event.sourceEvent.shiftKey || mode == COLOR)? d3.event.sourceEvent.altKey : !d3.event.sourceEvent.altKey)
		d3.select(this).classed("pinned", d.fixed = true);
}

function change_mode(m, c)
{
	d3.selectAll(".mode-button").classed("selected", false);
	mode = m;
	colorMode = c;
	switch (mode)
	{
		case DRAGPIN: break;
		case ADDEDGE:
			d3.select("#add-e-button").classed("selected", true);
			break;
		case ADDVERTEX:
			d3.select("#add-v-button").classed("selected", true);
			break;
		case CONTRACT:
			d3.select("#contract-button").classed("selected", true);
			break;
		case DELETE:
			d3.select("#delete-button").classed("selected", true);
			break;
		case COLOR:
			if (c == null)
				d3.select("#no-color-button").classed("selected", true);
			else
				d3.select("#" + c + "-button").classed("selected", true);
			break;
		default:
			console.log("unrecognized mode:" + m);
	}
	add_event_listeners();
}

function add_event_listeners()
{
	switch (mode)
	{
		case DRAGPIN:
			link.on("click", null)
				.on("mousedown", toggle_select);
			node.on("dblclick", unpin)
				.on("click", null)
				.on("mousedown", toggle_select)
				.call(drag);
		break;
		case ADDEDGE:
			link.on("click", null)
				.on("mousedown", toggle_select);
			node.on("click", toggle_select)
				.on("dblclick", null)
				.on("mousedown", null)
				.call(addEdgeDrag);
			break;
		case ADDVERTEX:
			console.log("unsupported feature: interactive add vertex");
			break;
		case CONTRACT:
			link.on("click", function (d) {
					contract_edge(d); update_graph(); write_g6(); force.start(); })
				.on("mousedown", null);
			node.on("dblclick", unpin)
				.on("click", null)
				.on("mousedown", toggle_select)
				.call(drag);
			break;
		case DELETE:
			link.on("click", function (d) {
					delete_edge(d); update_graph(); write_g6(); force.start(); })
				.on("mousedown", null);
			node.on("dblclick", null)
				.on("click",  function (d) {
					delete_vertex(d); update_graph(); write_g6(); force.start(); })
				.on("mousedown", null)
				.call(drag);
			break;
		case COLOR:
			if (colorMode == null)
			{
				link.on("click", remove_color)
					.on("mousedown", null);
				node.on("dblclick", unpin)
					.on("click", remove_color)
					.on("mousedown", null)
					.call(drag);
			}
			else
			{
				link.on("click", function()
						{ toggle_color(d3.select(this),colorMode); } )
					.on("mousedown", null);
				node.on("dblclick", unpin)
					.on("click", function()
						{ toggle_color(d3.select(this),colorMode); } )
					.on("mousedown", null)
					.call(drag);
			}
			break;
	}
}

function pin_all()
{
	drawingBoard.selectAll(".node").each(function (d) { d3.select(this).classed("pinned", d.fixed = true); });
}

function unpin_all()
{
	drawingBoard.selectAll(".node").each(unpin);
}

function select_all_nodes()
{
	drawingBoard.selectAll(".node").classed("selected", true);
}

function select_all_edges()
{
	drawingBoard.selectAll(".link").classed("selected", true);
}

function select_none()
{
	drawingBoard.selectAll(".selected").classed("selected", false);
}

function new_vertex()
{
	var newv = {id:nextID, label:nodes.length, x:getRandom(0,width), y:getRandom(0,height)};
	nodes.push(newv);
	nextID++;
	return newv;
}

function delete_vertex(d)
{
	for (var i=0; i < links.length;)
	{
		if (links[i].source.id == d.id || links[i].target.id == d.id)
		{
			links[i] = links[links.length-1];
			links.length--;
		}
		else
			i++;
	}
	
	for (var i=d.label+1; i<nodes.length; i++)
	{
		nodes[i].label--;
		nodes[i-1]=nodes[i];
	}
	nodes.length--;
}

function delete_edge(d)
{
	for (var i=0; i < links.length; i++)
	{
		if (links[i].source.id == d.source.id && links[i].target.id == d.target.id)
		{
			links[i] = links[links.length-1];
			links.length--;
			return;
		}
	}
}

function contract_edge(d, toDelete)
{
	if (d.source.id == d.target.id)
		return;
	var deleteNow = false;
	if (toDelete == null) // then delete the edges in this function
	{
		toDelete = [];
		toDelete.length = links.length;
		for (var i = 0; i < links.length; i++)
			toDelete[i] = false;
		deleteNow = true;
	}
	
	var adj=[];
	adj.length = nodes.length;
	for (var i = 0; i < nodes.length; i++)
		adj[i] = false;
	var v1 = Math.min(d.source.label, d.target.label);
	var v2 = Math.max(d.source.label, d.target.label);
	
	for (var i = 0; i < links.length;i++)
	{
		var l = links[i];
		
		if ((l.source.label == v1 && l.target.label == v2) || (l.target.label == v1 && l.source.label == v2))
		{
			toDelete[i] = true;
			l.source = l.target = nodes[v1];
		}
		else if (l.source.label == v1 || l.source.label == v2)
		{
			if (adj[l.target.label])
				toDelete[i] = true;
			adj[l.target.label] = true;
			l.source = nodes[v1];
		}
		else if (l.target.label == v1 || l.target.label == v2)
		{
			if (adj[l.source.label])
				toDelete[i] = true;
			adj[l.source.label] = true;
			l.target = nodes[v1];
		}
	}
	
	adj[d.source.label] = adj[d.target.label] = false;
	
	if (deleteNow)
	{
		for (var i = links.length - 1; i >= 0; i--)
		{
			if (toDelete[i])
			{
				links[i] = links[links.length-1];
				links.length--;
			}
		}
	}
	var avgx = (nodes[v1].x + nodes[v2].x)/2;
	var avgy = (nodes[v1].y + nodes[v2].y)/2;
	nodes[v1].px = avgx;
	nodes[v1].py = avgy;
	nodes[v1].x = avgx;
	nodes[v1].y = avgy;
	
	delete_vertex(nodes[v2]);
	
	if (d3.event.shiftKey)
			drawingBoard.selectAll(".node")
				.filter(function (d) { return d.label == v1; })
				.classed("selected", true);
}

function split_edge(d)
{
	var newv = new_vertex();
	links.push({source:newv, target:d.source});
	d.source = newv;
}

function add_vertex_button_press()
{
	var edges_selected = false;
	
	//split edges if they are selected
	var selected = drawingBoard.selectAll(".link.selected");
	if (!selected.empty())
	{
		selected.each(split_edge);
		edges_selected = true;
		update_graph();
	}
	
	selected = drawingBoard.selectAll(".node.selected");
	if (!selected.empty() || !edges_selected)
	{
		var newv = new_vertex();
		selected.each(function (d,i) { links.push({source:newv, target: d}); });
		update_graph();
		if (d3.event.shiftKey)
			drawingBoard.selectAll(".node")
				.filter(function (d) { return d.label == newv.label; })
				.classed("selected", true);
	}
	
	
	
	write_g6();
	force.start();
}


function add_edge_button_press()
{
	if (d3.select(this).classed("selected"))
		change_mode(DRAGPIN, null);
	else
		change_mode(ADDEDGE, null);
}

function toggle_select(d)
{
	if (d3.event.shiftKey)
	{
		var feature=d3.select(this);
		feature.classed("selected", !feature.classed("selected"));
	}
}

function remove_color(d)
{
	var feature=d3.select(this);
	if (d3.event.shiftKey)
		feature.classed("selected", !feature.classed("selected"));
	else
		feature.classed("red orange yellow green blue purple", false);
}

function toggle_color(feature, c)
{
	if (d3.event.shiftKey)
		feature.classed("selected", !feature.classed("selected"));
	else
	{
		var colored = feature.classed(c);
		feature.classed("red orange yellow green blue purple", false);
		feature.classed(c, !colored);
	}
}

function delete_button_press()
{
	var changes=false;
	var selected = drawingBoard.selectAll(".link.selected");
	if (!selected.empty())
	{
		selected.each(delete_edge);
		changes = true;
	}
	
	selected = drawingBoard.selectAll(".node.selected");
	if (!selected.empty())
	{
		selected.each(delete_vertex);
		changes = true;
	}
	
	if (changes)
	{
		update_graph();
		write_g6();
		force.start();
	}
	else
	{
		if (d3.select(this).classed("selected"))
			change_mode(DRAGPIN, null);
		else
			change_mode(DELETE, null);
	}
}

function contract_button_press()
{
	var toContract = [];
	var newv; // the label of the first vertex being contracted, which will be the resulting vertex.
	var adj = [];
	toContract.length = nodes.length;
	adj.length = nodes.length;
	for (var i = 0; i < nodes.length; i++)
		toContract[i] = adj[i] = false;
	selectedNodes = drawingBoard.selectAll(".node.selected").each( function (d) {toContract[d.label] = true;} );
	selectedLinks = drawingBoard.selectAll(".link.selected");
	
	if (selectedNodes.empty() && selectedLinks.empty())
	{
		if (d3.select(this).classed("selected"))
			change_mode(DRAGPIN, null);
		else
			change_mode(CONTRACT, null);
		return;
	}
	
	if (selectedNodes.empty())
	{
		toDelete = [];
		toDelete.length = links.length;
		for (var i = 0; i < links.length; i++)
			toDelete[i] = false;
		selectedLinks.each( function(d) { contract_edge(d, toDelete) } );
		for (var i = links.length - 1; i >= 0; i--) if (toDelete[i])
		{
			links[i] = links[links.length-1];
			links.length--;
		}
		update_graph();
		write_g6();
		force.start();
	}
	
	if (selectedLinks.empty())
	{
		for (var i = 0; i < links.length;)
		{
			var l = links[i];
			if (toContract[l.source.label] && !toContract[l.target.label])
			{
				adj[l.target.label] = true;
				links[i] = links[links.length-1];
				links.length--;
			}
			else if (!toContract[l.source.label] && toContract[l.target.label])
			{
				adj[l.source.label] = true;
				links[i] = links[links.length-1];
				links.length--;
			}
			else
				i++;
		}
	
		var numContract = 0, sumx=0, sumy=0;
		for (var i = 0; i < nodes.length; i++) if (toContract[i])
		{
			sumx += nodes[i].x;
			sumy += nodes[i].y;
			numContract++;
		}
	
		if (numContract == 0)
			return;
	
		for (var i = 0; i < nodes.length; i++)
		{
			if (toContract[i])
			{
				newv = i;
				toContract[i] = false;
				break;
			}
		}
		nodes[newv].px = sumx/numContract;
		nodes[newv].py = sumy/numContract;
		nodes[newv].x = sumx/numContract;
		nodes[newv].y = sumy/numContract;
	
		for (var i = nodes.length-1; i >=0; i--)
		{
			if (toContract[i]) // we won't delete a vertex before newv, and we don't
				delete_vertex(nodes[i]); // look at toContract or adj past where we
			else if (adj[i]) // are deleting vertices, so we shouldn't be corrupting
				links.push({source:nodes[i], target:nodes[newv]}); // anything.
		}
	
		update_graph();
		if (d3.event.shiftKey)
			drawingBoard.selectAll(".node")
				.filter(function (d) { return d.label == newv; })
				.classed("selected", true);
		else
			select_none();
		write_g6();
		force.start();
	}
}

function color_button_press(button, c)
{
	if (d3.event.shiftKey)
	{
		if (c!=null)
			drawingBoard.selectAll("."+c)
				.classed("selected", true);
	}
	else
	{
		var selected = drawingBoard.selectAll(".selected");
		if (selected.empty())
		{
			if (button.classed("selected"))
				change_mode(DRAGPIN, null);
			else
				change_mode(COLOR, c);
		}
		else
		{
			selected
				.classed("selected red orange yellow green blue purple", false);
			if (c != null)
				selected.classed(c, true);
		}
	}
}

function generate_TikZ()
{
	button = d3.select(this);
	
	if (button.classed("selected") || nodes.length == 0)
	{
		button.classed("selected",false)
		d3.select("#TikZ-div")
			.style("display","none");
		return;
	}
	
	d3
	tikz = "\\tikzset{vertex/.style={draw, fill, inner sep = .05cm, circle}}\n\\tikzset{edge/.style={thick}}\n\n% " + document.getElementById("graph-input").value + "\n\\begin{tikzpicture}[scale=5]";
	var min = Number.MAX_VALUE,
	    max = Number.MIN_VALUE;
	var printLabels = labelRect.classed("selected");

	for (var i = 0; i < nodes.length; i++)
	{
		min = Math.min(min, nodes[i].x);
		max = Math.max(max, nodes[i].x);
	}
	
	for (var i = 0; i < nodes.length; i++)
	{
		tikz += "\n\\node[vertex";
		if (printLabels)
			tikz += ", label=above:" + nodes[i].label;
		tikz += "] at (" + (nodes[i].x/(max-min)).toFixed(3) + "," + (-nodes[i].y/(max-min)).toFixed(3) + ") (v" + nodes[i].label + ") {};";
	}
	
	for (var i = 0; i < links.length; i++)
		tikz += "\n\\draw[edge] (v" + links[i].target.label + ") to (v" + links[i].source.label + ");";
	
	tikz += "\n\\end{tikzpicture}";
	
	button.classed("selected",true);
	d3.select("#TikZ-div")
		.style("display",null);
	d3.select("#TikZ-area")
		.text(tikz);
}

function check_show_labels()
{
	if (labelRect.classed("selected"))
		label.attr("visibility", "visible");
	else
		label.attr("visibility", "hidden");
}

function clear_graph()
{
	zoom.scale(1);
	zoom.translate([0,0]);
	zoomable.attr("transform", "");
	links.length=0;
	nodes.length=0;
	
	link = link.data(force.links(), function(d) { return d.source.id + "-" + d.target.id; });
	link.exit().remove();
	
	node = node.data(force.nodes(), function(d) { return d.id;});
	node.exit().remove();
	
	label = label.data(force.nodes(), function(d) { return d.id;});
	label.exit().remove();
}

function update_graph()
{
	link = link.data(force.links(), function(d) { return d.source.id + "-" + d.target.id; });
	link.enter()
		.append("line")
		.attr("class", "link");
	link.exit().remove();
	
	node = node.data(force.nodes(), function(d) { return d.id;});
	node
		.enter()
		.append("circle")
		.classed("node",true)
		.attr("r", "9px");
	node.exit().remove();
	
	label = label.data(force.nodes(), function(d) { return d.id;});
	label
		.text(function(d) { return d.label;})
		.enter()
		.append("text")
		.classed("label", true)
		.text(function(d) { return d.label;});
	label.exit().remove();
	
	add_event_listeners();
	check_show_labels();
}

function tick()
{
	node.attr("cx", function(d) { return d.x; })
	    .attr("cy", function(d) { return d.y; });
	
	link.attr("x1", function(d) { return d.source.x; })
	    .attr("y1", function(d) { return d.source.y; })
	    .attr("x2", function(d) { return d.target.x; })
	    .attr("y2", function(d) { return d.target.y; });
	
	label.attr("x", function(d) { return d.x; })
	     .attr("y", function(d) { return d.y; })
	     .attr("dy", "-14");
}

function write_g6()
{
	var nv = nodes.length;
	var g6string = "";
	if (nv > 0)
	{
		g6string += String.fromCharCode(nv + 63);
		var len = Math.ceil(nv*(nv-1)/12);
		for (var i = 0; i < len; i++)
			g6string += String.fromCharCode(63);
		for (var i = 0; i < links.length; i++)
		{
			var l = links[i];
			
			var V = Math.max(l.source.label, l.target.label);
			var v = Math.min(l.source.label, l.target.label);
			var c = Math.floor((V*(V-1)/2+v)/6);
			var b = 1 << (5-((V*(V-1)/2+v) % 6));
			g6string = g6string.substring(0, c+1) + String.fromCharCode(((g6string.charCodeAt(c+1) - 63) | b) + 63) + g6string.substring(c+2);
		}
	}
	document.getElementById("graph-input").value = g6string;
}

function load_g6(form)
{
	clear_graph();
	var g6string=form.g6.value;
	var g6i=0;
	var i, j, k, x;
	
	// if (*g6 == ':')
// 	{
// 		alert("Cannot read sparse6 format\n");
// 		return false;
// 	}
	
	var nv = g6string.charCodeAt(g6i) - 63;

	for (nextID=0; nextID<nv; nextID++)
	{
		nodes[nextID]={id:nextID, label:nextID, x:getRandom(0,width), y:getRandom(0,height)};
	}
	g6i++;
	
// 	if (g->nv > SMALLN) {
// 		for (i = 0, g->nv = 0; i < 3; ++i) {
// 			g->nv = (g->nv << 6) | (*g6++ -BIAS6);
// 		}
// 	}

// 	if (g->nv >= MAXNV)
// 	{
// 		fprintf(stderr, "Graph of size %d is larger than maximum size %d\n", g->nv, MAXNV);
// 		exit(1);
// 	}
	k = 1
	for (i = 1; i < nv; i++)
	{
		for (j = 0; j < i; j++)
		{
			k--;
			if (k==0)
			{
				k = 6;
				x = g6string.charCodeAt(g6i) - 63;
				g6i++;
			}
			if ((x >> 5) & 1)
			{
				links.push({source:nodes[i], target:nodes[j]});
			}
			x <<= 1;
		}
	}
	
	update_graph();
	force.start();
 	return false;
}

</script>

<body>
